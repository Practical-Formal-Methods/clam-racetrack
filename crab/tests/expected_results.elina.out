Program 1: forall 0<= i< 10. a[i] = 123456
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {n1 -> [1, 1]; i -> [0, 10]; A0_prop -> [0, 0]; smashed(A0) -> [0, 123456]})
bb1_f=({}, {n1 -> [1, 1]; i -> [0, 10]; A0_prop -> [0, 0]; smashed(A0) -> [0, 123456]})
ret=({}, {n1 -> [1, 1]; i -> [10, 10]; A0_prop -> [0, 0]; smashed(A0) -> [0, 123456]})
bb1_t=({}, {n1 -> [1, 1]; i -> [0, 10]; A0_prop -> [0, 0]; smashed(A0) -> [0, 123456]})
bb2=({}, {n1 -> [1, 1]; i -> [0, 9]; A0_prop -> [0, 0]; smashed(A0) -> [0, 123456]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 2: forall 0<= i< 10. a[i] = b[i] = x and x = 123456
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; smashed(B) -> [0, 123456]; smashed(A) -> [0, 123456]})
bb1_f=({}, {n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; smashed(B) -> [0, 123456]; smashed(A) -> [0, 123456]})
ret=({}, {n1 -> [1, 1]; i -> [10, 10]; A_p -> [0, 0]; smashed(B) -> [0, 123456]; smashed(A) -> [0, 123456]})
bb1_t=({}, {n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; smashed(B) -> [0, 123456]; smashed(A) -> [0, 123456]})
bb2=({}, {n1 -> [1, 1]; i -> [0, 9]; A_p -> [0, 0]; smashed(B) -> [0, 123456]; smashed(A) -> [0, 123456]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 3: forall 0<= i< 10. a[i] = 8 and b[i] = 5
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; smashed(B) -> [0, 5]; smashed(A) -> [0, 8]})
bb1_f=({}, {n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; smashed(B) -> [0, 5]; smashed(A) -> [0, 8]})
ret=({}, {n1 -> [1, 1]; i -> [10, 10]; A_p -> [0, 0]; smashed(B) -> [0, 5]; smashed(A) -> [0, 8]})
bb1_t=({}, {n1 -> [1, 1]; i -> [0, 10]; A_p -> [0, 0]; smashed(B) -> [0, 5]; smashed(A) -> [0, 8]})
bb2=({}, {n1 -> [1, 1]; i -> [0, 9]; A_p -> [0, 0]; smashed(B) -> [0, 5]; smashed(A) -> [0, 8]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 4: forall 0<= i < n. a[i] = 123456 (unbounded loop)
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
CRAB WARNING: array adaptive store range ignored because upper bound n is not constant
entry=({}, {})
bb1=({}, {n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
bb1_f=({}, {n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
ret=({}, {n1 -> [1, 1]; i -> [1, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
bb1_t=({}, {n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
bb2=({}, {n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 5: for all 0<= i< 10. a[i] = 123456 (assume elem size=4 bytes)
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {i -> [0, 10]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
bb1_f=({}, {i -> [0, 10]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
ret=({}, {i -> [10, 10]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
bb1_t=({}, {i -> [0, 10]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
bb2=({}, {i -> [0, 9]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 6: a[0] = 89 and for all 1<= i < n. a[i] = a[i-1]
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
CRAB WARNING: array adaptive store range ignored because upper bound n is not constant
entry=({}, {})
bb1=({}, {n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A_p -> [0, 0]; val -> [89, 89]})
bb1_f=({}, {n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A_p -> [0, 0]; val -> [89, 89]})
ret=({}, {n1 -> [1, 1]; i -> [2, +oo]; n -> [2, +oo]; A_p -> [0, 0]; val -> [89, 89]})
bb1_t=({}, {n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A_p -> [0, 0]; val -> [89, 89]})
bb2=({}, {n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A_p -> [0, 0]; val -> [89, 89]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 7: forall 0<= i< 10 and i % 2 = 0. a[i] = 123456
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 11]; n -> [1, +oo]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
bb1_f=({}, {n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 11]; n -> [1, +oo]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
ret=({}, {n1 -> [1, 1]; n2 -> [2, 2]; i -> [10, 11]; n -> [1, +oo]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
bb1_t=({}, {n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 11]; n -> [1, +oo]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
bb2=({}, {n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 9]; n -> [1, +oo]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 8: forall 0<= i < n. 1 <= a[i] <= 2
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
CRAB WARNING: array adaptive store range ignored because upper bound n is not constant
entry=({}, {})
bb1=({}, {n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
bb1_f2=({}, {n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
bb1_f=({}, {n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
ret=({}, {n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
bb1_f1=({}, {n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
bb1_t=({}, {n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
bb2=({}, {n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
bb2b=({}, {n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
bb2a=({}, {n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A_p -> [0, 0]})
Abstract trace: entry (bb1 bb1_t bb2 bb2b bb2a)^{3} bb1_f2 bb1_f1 bb1_f ret

Program 9: forall 0<= i < n. a[i] == 123456 (decrementing loop)
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({}, {n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
bb1_f=({}, {n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
ret=({}, {n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, -1]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
bb1_t=({}, {n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
bb2=({}, {n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [0, 9]; A_p -> [0, 0]; smashed(A) -> [0, 123456]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 11: forall 0<= i< 10. a[i] = true and b[i] = false
Invariants using ArrayAdaptive(ArraySmashing(Product(Boolean,Intervals)))
entry=({}, {})
bb1=({TRUE -> true; FALSE -> false; smashed(B) -> false; smashed(A) -> true}, {n1 -> [1, 1]; i -> [0, 10]})
bb1_f=({TRUE -> true; FALSE -> false; smashed(B) -> false; smashed(A) -> true}, {n1 -> [1, 1]; i -> [0, 10]})
ret=({TRUE -> true; FALSE -> false; smashed(B) -> false; smashed(A) -> true}, {n1 -> [1, 1]; i -> [10, 10]})
bb1_t=({TRUE -> true; FALSE -> false; smashed(B) -> false; smashed(A) -> true}, {n1 -> [1, 1]; i -> [0, 10]})
bb2=({TRUE -> true; FALSE -> false; smashed(B) -> false; smashed(A) -> true}, {n1 -> [1, 1]; i -> [0, 9]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

===================================
 Test 1 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
bb0={}
bb2={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t4[_x4], Mem[2...5] -> t3[_x3], Mem[6...9] -> t1[_x1], Mem[10...13] -> t4[_x4]}{_x0 -> [2, 2]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x3 -> [5, 5]; _x4 -> [7, 7]}
bb3={x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y4], Mem[2...5] -> t4[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y4]}{_y0 -> [2, 2]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [5, 5]; _y4 -> [7, 7]}
bb1={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t4[_x4], Mem[2...5] -> t3[_x3], Mem[6...9] -> t1[_x1], Mem[10...13] -> t4[_x4]}{_x0 -> [2, 2]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x3 -> [5, 5]; _x4 -> [7, 7]}
Abstract trace: bb0 bb2 bb1 bb3
 --- SAFE --------------------
Property : tmp1-tmp2 = -2
Invariant: {x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y4], tmp1 -> t4[_y3], tmp2 -> t3[_y4], Mem[2...5] -> t4[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y4]}{_y0 -> [2, 2]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [5, 5]; _y4 -> [7, 7]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 2 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
bb0={}
bb2={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t3[_x4], Mem[6...9] -> t1[_x1], Mem[10...13] -> t3[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x4 -> [7, 7]}
bb3={x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y3]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [7, 7]}
bb1={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t3[_x4], Mem[6...9] -> t1[_x1], Mem[10...13] -> t3[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x4 -> [7, 7]}
Abstract trace: bb0 bb2 bb1 bb3
 --- WARNING -----------------
Property : tmp1-tmp2 = -1
Invariant: {x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y3], tmp2 -> t1[_y1], tmp3 -> t3[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y3]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [7, 7]}
 -----------------------------
 --- SAFE --------------------
Property : tmp2-tmp3 = -1
Invariant: {x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y3], tmp1 -> t4[_y4], tmp2 -> t1[_y1], tmp3 -> t3[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y3]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [7, 7]; _y4 -> [5, 5]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
1  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 3 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
bb0={}
bb2={x -> t0[_x0], x1 -> t0[_x0], x2 -> t1[_x1], x3 -> t2[_x2], x4 -> t3[_x3], val -> t4[_x4], Mem[4...11] -> t4[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [8, 8]; _x3 -> [10, 10]; _x4 -> [0, 0]}
bb3={x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]}
bb1={x -> t0[_x0], x1 -> t0[_x0], x2 -> t1[_x1], x3 -> t2[_x2], x4 -> t3[_x3], val -> t4[_x4], Mem[4...11] -> t4[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [8, 8]; _x3 -> [10, 10]; _x4 -> [0, 0]}
Abstract trace: bb0 bb2 bb1 bb3
 --- WARNING -----------------
Property : tmp1 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]}
 -----------------------------
 --- WARNING -----------------
Property : tmp2 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], tmp1 -> t5[_y5], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]; _y5 -> [0, 0]}
 -----------------------------
 --- WARNING -----------------
Property : tmp3 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], tmp1 -> t5[_y5], tmp2 -> t6[_y6], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]; _y5 -> [0, 0]; _y6 -> [0, 0]}
 -----------------------------
 --- WARNING -----------------
Property : tmp4 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], tmp1 -> t5[_y5], tmp2 -> t6[_y6], tmp3 -> t7[_y7], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]; _y5 -> [0, 0]; _y6 -> [0, 0]; _y7 -> [0, 0]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
0  Number of total safe checks
0  Number of total error checks
4  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 4 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
loop1_entry={}
loop1_bb1={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 10]}
loop1_bb1_f={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 10]}
loop2_entry={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], *i -> t6[_y6], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [10, 10]}
loop2_bb1={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 10]; _x7 -> [10, 10]}
loop2_bb1_f={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 10]; _x7 -> [10, 10]}
ret={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [10, 10]; _x7 -> [10, 10]}
loop2_bb1_t={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 10]; _x7 -> [10, 10]}
loop2_bb2={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 9]; _x7 -> [10, 10]}
loop1_bb1_t={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 10]}
loop1_bb2={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], *i -> t6[_y6], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 9]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
 --- SAFE --------------------
Property : *i = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [10, 10]; _x7 -> [10, 10]}
 -----------------------------
 --- SAFE --------------------
Property : *j = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [10, 10]; _x7 -> [10, 10]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 5 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
loop1_entry={}
loop1_bb1={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t11[_y9], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y1 -> [0, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y7 -> [1, 124]; _y8 -> [224, 224]; _y9 -> [1, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 10]; _y13 -> [0, 0]}
loop1_bb1_f={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t11[_y9], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y1 -> [0, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y7 -> [1, 124]; _y8 -> [224, 224]; _y9 -> [1, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 10]; _y13 -> [0, 0]}
loop2_entry={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t13[_y12], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y8 -> [224, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [10, 10]; _y13 -> [0, 0]}
loop2_bb1={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t12[_x11], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x1 -> [0, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x9 -> [1, 128]; _x10 -> [228, 228]; _x11 -> [1, 228]; _x12 -> [0, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop2_bb1_f={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t12[_x11], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x1 -> [0, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x9 -> [1, 128]; _x10 -> [228, 228]; _x11 -> [1, 228]; _x12 -> [0, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
ret={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [10, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop2_bb1_t={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t12[_x11], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x1 -> [0, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x9 -> [1, 128]; _x10 -> [228, 228]; _x11 -> [1, 228]; _x12 -> [0, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop2_bb2={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [0, 9]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop1_bb1_t={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t11[_y9], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y1 -> [0, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y7 -> [1, 124]; _y8 -> [224, 224]; _y9 -> [1, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 10]; _y13 -> [0, 0]}
loop1_bb2={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t13[_y12], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y8 -> [224, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 9]; _y13 -> [0, 0]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
 --- SAFE --------------------
Property : *i = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [10, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
 -----------------------------
 --- SAFE --------------------
Property : *j = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [10, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 6 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
loop1_entry={}
loop1_bb1={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t9[_y8], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y8 -> [-124, 10]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop1_bb1_f={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t9[_y8], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y8 -> [-124, 10]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop2_entry={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t10[_y1], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [10, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop2_bb1={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t10[_x10], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x10 -> [-128, 10]; _x11 -> [10, 10]}
loop2_bb1_f={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t10[_x10], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x10 -> [-128, 10]; _x11 -> [10, 10]}
ret={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [10, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
loop2_bb1_t={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t10[_x10], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x10 -> [-128, 10]; _x11 -> [10, 10]}
loop2_bb2={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 9]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
loop1_bb1_t={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t9[_y8], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y8 -> [-124, 10]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop1_bb2={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t10[_y1], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 9]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
 --- SAFE --------------------
Property : *i = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [10, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
 -----------------------------
 --- SAFE --------------------
Property : *j = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [10, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 7 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
entry={}
ret={x -> t0[_x0], y -> t0[_x0], z -> t0[_x0], val -> t3[_x3], tmp1 -> t1[_x1], tmp2 -> t2[_x2], tmp3 -> t3[_x3], Mem1[4...7] -> t1[_x1], Mem2[4...7] -> t2[_x2], Mem3[4...7] -> t3[_x3]}{_x0 -> [4, 4]; _x1 -> [42, 42]; _x2 -> [43, 43]; _x3 -> [44, 44]}
Abstract trace: entry ret
 --- SAFE --------------------
Property : tmp1-tmp2 < 0
Invariant: {x -> t0[_x0], y -> t0[_x0], z -> t0[_x0], val -> t3[_x3], tmp1 -> t1[_x1], tmp2 -> t2[_x2], tmp3 -> t3[_x3], Mem1[4...7] -> t1[_x1], Mem2[4...7] -> t2[_x2], Mem3[4...7] -> t3[_x3]}{_x0 -> [4, 4]; _x1 -> [42, 42]; _x2 -> [43, 43]; _x3 -> [44, 44]}
 -----------------------------
 --- SAFE --------------------
Property : tmp2-tmp3 < 0
Invariant: {x -> t0[_x0], y -> t0[_x0], z -> t0[_x0], val -> t3[_x3], tmp1 -> t1[_x1], tmp2 -> t2[_x2], tmp3 -> t3[_x3], Mem1[4...7] -> t1[_x1], Mem2[4...7] -> t2[_x2], Mem3[4...7] -> t3[_x3]}{_x0 -> [4, 4]; _x1 -> [42, 42]; _x2 -> [43, 43]; _x3 -> [44, 44]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 8 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
entry={}
ret={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t5[_x5], tmp1 -> t3[_x3], tmp2 -> t4[_x4], tmp3 -> t5[_x5], Mem1[4...7] -> t3[_x3], Mem2[5...8] -> t4[_x4], Mem3[6...9] -> t5[_x5]}{_x0 -> [4, 4]; _x1 -> [5, 5]; _x2 -> [6, 6]; _x3 -> [42, 42]; _x4 -> [43, 43]; _x5 -> [44, 44]}
Abstract trace: entry ret
 --- SAFE --------------------
Property : tmp1-tmp2 < 0
Invariant: {x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t5[_x5], tmp1 -> t3[_x3], tmp2 -> t4[_x4], tmp3 -> t5[_x5], Mem1[4...7] -> t3[_x3], Mem2[5...8] -> t4[_x4], Mem3[6...9] -> t5[_x5]}{_x0 -> [4, 4]; _x1 -> [5, 5]; _x2 -> [6, 6]; _x3 -> [42, 42]; _x4 -> [43, 43]; _x5 -> [44, 44]}
 -----------------------------
 --- SAFE --------------------
Property : tmp2-tmp3 < 0
Invariant: {x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t5[_x5], tmp1 -> t3[_x3], tmp2 -> t4[_x4], tmp3 -> t5[_x5], Mem1[4...7] -> t3[_x3], Mem2[5...8] -> t4[_x4], Mem3[6...9] -> t5[_x5]}{_x0 -> [4, 4]; _x1 -> [5, 5]; _x2 -> [6, 6]; _x3 -> [42, 42]; _x4 -> [43, 43]; _x5 -> [44, 44]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 9 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
entry={}
ret={m1_lb -> t0[_x0], m1_ub -> t1[_x1], x -> t3[_x3], y -> t4[_x4], tmp1 -> t2[_x2], tmp2 -> t2[_x2], Mem1[20...23] -> t2[_x2], Mem1[24...27] -> t2[_x2], Mem1[28...31] -> t2[_x2], Mem1[32...35] -> t2[_x2], Mem1[36...39] -> t2[_x2], Mem1[40...43] -> t2[_x2], Mem1[44...47] -> t2[_x2], Mem1[48...51] -> t2[_x2], Mem1[52...55] -> t2[_x2], Mem1[56...59] -> t2[_x2], Mem1[60...63] -> t2[_x2], Mem1[64...67] -> t2[_x2], Mem1[68...71] -> t2[_x2], Mem1[72...75] -> t2[_x2], Mem1[76...79] -> t2[_x2], Mem1[80...83] -> t2[_x2]}{_x0 -> [20, 20]; _x1 -> [80, 80]; _x2 -> [42, 42]; _x3 -> [24, 24]; _x4 -> [76, 76]}
Abstract trace: entry ret
 --- SAFE --------------------
Property : tmp1-tmp2 = 0
Invariant: {m1_lb -> t0[_x0], m1_ub -> t1[_x1], x -> t3[_x3], y -> t4[_x4], tmp1 -> t2[_x2], tmp2 -> t2[_x2], Mem1[20...23] -> t2[_x2], Mem1[24...27] -> t2[_x2], Mem1[28...31] -> t2[_x2], Mem1[32...35] -> t2[_x2], Mem1[36...39] -> t2[_x2], Mem1[40...43] -> t2[_x2], Mem1[44...47] -> t2[_x2], Mem1[48...51] -> t2[_x2], Mem1[52...55] -> t2[_x2], Mem1[56...59] -> t2[_x2], Mem1[60...63] -> t2[_x2], Mem1[64...67] -> t2[_x2], Mem1[68...71] -> t2[_x2], Mem1[72...75] -> t2[_x2], Mem1[76...79] -> t2[_x2], Mem1[80...83] -> t2[_x2]}{_x0 -> [20, 20]; _x1 -> [80, 80]; _x2 -> [42, 42]; _x3 -> [24, 24]; _x4 -> [76, 76]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 10 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
bb0={}
bb2={Mem1[2...5] -> t0[_x0]}{_x0 -> [42, 42]}
bb3={Mem1[2...5] -> t0[_y0]}{_y0 -> [42, 42]}
bb4={x -> t0[_y1], Mem1[2...5] -> t0[_y1]}{_y1 -> [42, 42]}
bb1={Mem1[2...5] -> t0[_x0]}{_x0 -> [42, 42]}
Abstract trace: bb0 bb2 bb1 bb3 bb4
 --- WARNING -----------------
Property : x = 42
Invariant: {x -> t0[_y1], Mem1[2...5] -> t0[_y1]}{}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 11 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
bb0={}
bb2={Mem1[2...5] -> t0[_x0], Mem2[2...5] -> t1[_x1], Mem1[6...9] -> t2[_x2]}{_x0 -> [42, 42]; _x1 -> [666, 666]; _x2 -> [50, 50]}
bb3={i -> t0[_y3], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
bb4={i -> t0[_y3], x -> t1[_y0], y -> t3[_y2], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
bb1={Mem1[2...5] -> t0[_x0], Mem2[2...5] -> t1[_x1], Mem1[6...9] -> t2[_x2]}{_x0 -> [42, 42]; _x1 -> [666, 666]; _x2 -> [50, 50]}
Abstract trace: bb0 bb2 bb1 bb3 bb4
 --- SAFE --------------------
Property : x = 42
Invariant: {i -> t0[_y3], x -> t1[_y0], y -> t3[_y2], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
 -----------------------------
 --- SAFE --------------------
Property : y = 50
Invariant: {i -> t0[_y3], x -> t1[_y0], y -> t3[_y2], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 12 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
bb0={}
Abstract trace: bb0
 --- SAFE --------------------
Property : x = 42
Invariant: {x -> t0[_x0], y -> t1[_x1], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t1[_x1]}{_x0 -> [42, 42]; _x1 -> [50, 50]}
 -----------------------------
 --- SAFE --------------------
Property : y = 50
Invariant: {x -> t0[_x0], y -> t1[_x1], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t1[_x1]}{_x0 -> [42, 42]; _x1 -> [50, 50]}
 -----------------------------
 --- SAFE --------------------
Property : x = 666
Invariant: {i -> t2[_x2], j -> t3[_x3], x -> t4[_x4], y -> t4[_x4], Mem1[0...3] -> t4[_x4], Mem1[4...7] -> t4[_x4], Mem1[8...11] -> t4[_x4]}{_x2 -> [0, 0]; _x3 -> [8, 8]; _x4 -> [666, 666]}
 -----------------------------
 --- SAFE --------------------
Property : y = 666
Invariant: {i -> t2[_x2], j -> t3[_x3], x -> t4[_x4], y -> t4[_x4], Mem1[0...3] -> t4[_x4], Mem1[4...7] -> t4[_x4], Mem1[8...11] -> t4[_x4]}{_x2 -> [0, 0]; _x3 -> [8, 8]; _x4 -> [666, 666]}
 -----------------------------
 --- WARNING -----------------
Property : y = 666
Invariant: {i -> t1[_x5], j -> t3[_x3], Mem1[2...5] -> t2[_x6], Mem1[6...9] -> t2[_x6]}{_x3 -> [8, 8]; _x5 -> [2, 2]; _x6 -> [777, 777]}
 -----------------------------
 --- WARNING -----------------
Property : x = 666
Invariant: {i -> t1[_x5], j -> t3[_x3], y -> t4[_x7], Mem1[2...5] -> t2[_x6], Mem1[6...9] -> t2[_x6]}{_x3 -> [8, 8]; _x5 -> [2, 2]; _x6 -> [777, 777]; _x7 -> [666, 666]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
4  Number of total safe checks
0  Number of total error checks
2  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 13 for array adaptive domain 
===================================
Invariants using ArrayAdaptive(ArraySmashing(Term(Intervals)))
bb0={}
Abstract trace: bb0
 --- SAFE --------------------
Property : x = 42
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t0[_x0], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [12, 12]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 0
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t5[_x5], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [12, 12]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 0
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t5[_x5], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [12, 12]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 0
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t5[_x5], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [12, 12]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 50
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t2[_x2], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [12, 12]; _x5 -> [0, 0]}
 -----------------------------
user-defined assertion checker using ArrayAdaptive(ArraySmashing(Term(Intervals)))
5  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 1 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
bb0={}
bb2={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t4[_x4], Mem[2...5] -> t3[_x3], Mem[6...9] -> t1[_x1], Mem[10...13] -> t4[_x4]}{_x0 -> [2, 2]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x3 -> [5, 5]; _x4 -> [7, 7]}
bb3={x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y4], Mem[2...5] -> t4[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y4]}{_y0 -> [2, 2]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [5, 5]; _y4 -> [7, 7]}
bb1={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t4[_x4], Mem[2...5] -> t3[_x3], Mem[6...9] -> t1[_x1], Mem[10...13] -> t4[_x4]}{_x0 -> [2, 2]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x3 -> [5, 5]; _x4 -> [7, 7]}
Abstract trace: bb0 bb2 bb1 bb3
 --- SAFE --------------------
Property : tmp1-tmp2 = -2
Invariant: {x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y4], tmp1 -> t4[_y3], tmp2 -> t3[_y4], Mem[2...5] -> t4[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y4]}{_y0 -> [2, 2]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [5, 5]; _y4 -> [7, 7]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 2 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
CRAB WARNING: Ignored read from cell Mem[4...7] because it overlaps with 1 cells
bb0={}
bb2={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t3[_x4], Mem[6...9] -> t1[_x1], Mem[10...13] -> t3[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x4 -> [7, 7]}
bb3={x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y3]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [7, 7]}
bb1={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t3[_x4], Mem[6...9] -> t1[_x1], Mem[10...13] -> t3[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [10, 10]; _x4 -> [7, 7]}
Abstract trace: bb0 bb2 bb1 bb3
CRAB WARNING: Ignored read from cell Mem[4...7] because it overlaps with 1 cells
 --- WARNING -----------------
Property : tmp1-tmp2 = -1
Invariant: {x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y3], tmp2 -> t1[_y1], tmp3 -> t3[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y3]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [7, 7]}
 -----------------------------
 --- SAFE --------------------
Property : tmp2-tmp3 = -1
Invariant: {x -> t0[_y0], y -> t1[_y1], z -> t2[_y2], val -> t3[_y3], tmp1 -> t4[_y4], tmp2 -> t1[_y1], tmp3 -> t3[_y3], Mem[6...9] -> t1[_y1], Mem[10...13] -> t3[_y3]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [10, 10]; _y3 -> [7, 7]; _y4 -> [5, 5]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
1  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 3 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
CRAB WARNING: Ignored read from cell Mem[4...5] because it overlaps with 1 cells
CRAB WARNING: Ignored read from cell Mem[6...7] because it overlaps with 1 cells
CRAB WARNING: Ignored read from cell Mem[8...9] because it overlaps with 1 cells
CRAB WARNING: Ignored read from cell Mem[10...11] because it overlaps with 1 cells
bb0={}
bb2={x -> t0[_x0], x1 -> t0[_x0], x2 -> t1[_x1], x3 -> t2[_x2], x4 -> t3[_x3], val -> t4[_x4], Mem[4...11] -> t4[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [8, 8]; _x3 -> [10, 10]; _x4 -> [0, 0]}
bb3={x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]}
bb1={x -> t0[_x0], x1 -> t0[_x0], x2 -> t1[_x1], x3 -> t2[_x2], x4 -> t3[_x3], val -> t4[_x4], Mem[4...11] -> t4[_x4]}{_x0 -> [4, 4]; _x1 -> [6, 6]; _x2 -> [8, 8]; _x3 -> [10, 10]; _x4 -> [0, 0]}
Abstract trace: bb0 bb2 bb1 bb3
CRAB WARNING: Ignored read from cell Mem[4...5] because it overlaps with 1 cells
CRAB WARNING: Ignored read from cell Mem[6...7] because it overlaps with 1 cells
CRAB WARNING: Ignored read from cell Mem[8...9] because it overlaps with 1 cells
CRAB WARNING: Ignored read from cell Mem[10...11] because it overlaps with 1 cells
 --- WARNING -----------------
Property : tmp1 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]}
 -----------------------------
 --- WARNING -----------------
Property : tmp2 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], tmp1 -> t5[_y5], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]; _y5 -> [0, 0]}
 -----------------------------
 --- WARNING -----------------
Property : tmp3 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], tmp1 -> t5[_y5], tmp2 -> t6[_y6], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]; _y5 -> [0, 0]; _y6 -> [0, 0]}
 -----------------------------
 --- WARNING -----------------
Property : tmp4 = 0
Invariant: {x -> t0[_y0], x1 -> t0[_y0], x2 -> t1[_y1], x3 -> t2[_y2], x4 -> t3[_y3], tmp1 -> t5[_y5], tmp2 -> t6[_y6], tmp3 -> t7[_y7], val -> t4[_y4], Mem[4...11] -> t4[_y4]}{_y0 -> [4, 4]; _y1 -> [6, 6]; _y2 -> [8, 8]; _y3 -> [10, 10]; _y4 -> [0, 0]; _y5 -> [0, 0]; _y6 -> [0, 0]; _y7 -> [0, 0]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
0  Number of total safe checks
0  Number of total error checks
4  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 4 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
loop1_entry={}
loop1_bb1={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 10]}
loop1_bb1_f={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 10]}
loop2_entry={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], *i -> t6[_y6], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [10, 10]}
loop2_bb1={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 10]; _x7 -> [10, 10]}
loop2_bb1_f={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 10]; _x7 -> [10, 10]}
ret={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [10, 10]; _x7 -> [10, 10]}
loop2_bb1_t={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 10]; _x7 -> [10, 10]}
loop2_bb2={Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [0, 9]; _x7 -> [10, 10]}
loop1_bb1_t={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 10]}
loop1_bb2={Mem_base -> t0[_y0], i -> t2[_y2], j -> t4[_y4], *i -> t6[_y6], val0 -> t5[_y5], Mem[108...111] -> t6[_y6]}{_y0 -> [100, 100]; _y1 -> [8, 8]; _y2 -> [108, 108]; _y3 -> [12, 12]; _y4 -> [112, 112]; _y5 -> [0, 0]; _y6 -> [0, 9]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
 --- SAFE --------------------
Property : *i = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [10, 10]; _x7 -> [10, 10]}
 -----------------------------
 --- SAFE --------------------
Property : *j = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x2], j -> t4[_x4], *i -> t5[_x7], *j -> t7[_x6], val0 -> t6[_x5], Mem[108...111] -> t5[_x7], Mem[112...115] -> t7[_x6]}{_x0 -> [100, 100]; _x1 -> [8, 8]; _x2 -> [108, 108]; _x3 -> [12, 12]; _x4 -> [112, 112]; _x5 -> [0, 0]; _x6 -> [10, 10]; _x7 -> [10, 10]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 5 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
loop1_entry={}
loop1_bb1={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t11[_y9], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y1 -> [0, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y7 -> [1, 124]; _y8 -> [224, 224]; _y9 -> [1, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 10]; _y13 -> [0, 0]}
loop1_bb1_f={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t11[_y9], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y1 -> [0, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y7 -> [1, 124]; _y8 -> [224, 224]; _y9 -> [1, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 10]; _y13 -> [0, 0]}
loop2_entry={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t13[_y12], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y8 -> [224, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [10, 10]; _y13 -> [0, 0]}
loop2_bb1={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t12[_x11], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x1 -> [0, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x9 -> [1, 128]; _x10 -> [228, 228]; _x11 -> [1, 228]; _x12 -> [0, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop2_bb1_f={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t12[_x11], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x1 -> [0, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x9 -> [1, 128]; _x10 -> [228, 228]; _x11 -> [1, 228]; _x12 -> [0, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
ret={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [10, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop2_bb1_t={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t12[_x11], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x1 -> [0, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x9 -> [1, 128]; _x10 -> [228, 228]; _x11 -> [1, 228]; _x12 -> [0, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop2_bb2={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [0, 9]; _x13 -> [0, 0]; _x14 -> [10, 10]}
loop1_bb1_t={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t11[_y9], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y1 -> [0, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y7 -> [1, 124]; _y8 -> [224, 224]; _y9 -> [1, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 10]; _y13 -> [0, 0]}
loop1_bb2={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y8], jj -> t8[_y11], *i -> t13[_y12], val0 -> t12[_y13], Mem[124...127] -> t6[_y8], Mem[128...131] -> t8[_y11], Mem[224...227] -> t13[_y12]}{_y0 -> [100, 100]; _y2 -> [24, 24]; _y3 -> [124, 124]; _y4 -> [28, 28]; _y5 -> [128, 128]; _y6 -> [124, 124]; _y8 -> [224, 224]; _y10 -> [128, 128]; _y11 -> [228, 228]; _y12 -> [0, 9]; _y13 -> [0, 0]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
 --- SAFE --------------------
Property : *i = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [10, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
 -----------------------------
 --- SAFE --------------------
Property : *j = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x10], *i -> t9[_x14], *j -> t14[_x12], val0 -> t13[_x13], Mem[124...127] -> t6[_x7], Mem[128...131] -> t8[_x10], Mem[224...227] -> t9[_x14], Mem[228...231] -> t14[_x12]}{_x0 -> [100, 100]; _x2 -> [24, 24]; _x3 -> [124, 124]; _x4 -> [28, 28]; _x5 -> [128, 128]; _x6 -> [124, 124]; _x7 -> [224, 224]; _x8 -> [128, 128]; _x10 -> [228, 228]; _x12 -> [10, 10]; _x13 -> [0, 0]; _x14 -> [10, 10]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 6 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
loop1_entry={}
loop1_bb1={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t9[_y8], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y8 -> [-124, 10]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop1_bb1_f={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t9[_y8], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y8 -> [-124, 10]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop2_entry={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t10[_y1], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [10, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop2_bb1={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t10[_x10], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x10 -> [-128, 10]; _x11 -> [10, 10]}
loop2_bb1_f={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t10[_x10], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x10 -> [-128, 10]; _x11 -> [10, 10]}
ret={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [10, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
loop2_bb1_t={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t10[_x10], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x10 -> [-128, 10]; _x11 -> [10, 10]}
loop2_bb2={Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [0, 9]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
loop1_bb1_t={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t9[_y8], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 10]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y8 -> [-124, 10]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
loop1_bb2={Mem_base -> t0[_y0], i -> t2[_y3], j -> t4[_y5], ii -> t6[_y7], jj -> t8[_y10], *i -> t10[_y1], val0 -> t0[_y0], Mem[18446744073709551592...18446744073709551595] -> t6[_y7], Mem[18446744073709551588...18446744073709551591] -> t8[_y10], Mem[18446744073709551492...18446744073709551495] -> t10[_y1]}{_y0 -> [0, 0]; _y1 -> [0, 9]; _y2 -> [24, 24]; _y3 -> [-24, -24]; _y4 -> [28, 28]; _y5 -> [-28, -28]; _y6 -> [124, 124]; _y7 -> [-124, -124]; _y9 -> [128, 128]; _y10 -> [-128, -128]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret
 --- SAFE --------------------
Property : *i = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [10, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
 -----------------------------
 --- SAFE --------------------
Property : *j = 10
Invariant: {Mem_base -> t0[_x0], i -> t2[_x3], j -> t4[_x5], ii -> t6[_x7], jj -> t8[_x9], *i -> t9[_x11], *j -> t11[_x1], val0 -> t0[_x0], Mem[18446744073709551592...18446744073709551595] -> t6[_x7], Mem[18446744073709551588...18446744073709551591] -> t8[_x9], Mem[18446744073709551492...18446744073709551495] -> t9[_x11], Mem[18446744073709551488...18446744073709551491] -> t11[_x1]}{_x0 -> [0, 0]; _x1 -> [10, 10]; _x2 -> [24, 24]; _x3 -> [-24, -24]; _x4 -> [28, 28]; _x5 -> [-28, -28]; _x6 -> [124, 124]; _x7 -> [-124, -124]; _x8 -> [128, 128]; _x9 -> [-128, -128]; _x11 -> [10, 10]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 7 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
entry={}
ret={x -> t0[_x0], y -> t0[_x0], z -> t0[_x0], val -> t3[_x3], tmp1 -> t1[_x1], tmp2 -> t2[_x2], tmp3 -> t3[_x3], Mem1[4...7] -> t1[_x1], Mem2[4...7] -> t2[_x2], Mem3[4...7] -> t3[_x3]}{_x0 -> [4, 4]; _x1 -> [42, 42]; _x2 -> [43, 43]; _x3 -> [44, 44]}
Abstract trace: entry ret
 --- SAFE --------------------
Property : tmp1-tmp2 < 0
Invariant: {x -> t0[_x0], y -> t0[_x0], z -> t0[_x0], val -> t3[_x3], tmp1 -> t1[_x1], tmp2 -> t2[_x2], tmp3 -> t3[_x3], Mem1[4...7] -> t1[_x1], Mem2[4...7] -> t2[_x2], Mem3[4...7] -> t3[_x3]}{_x0 -> [4, 4]; _x1 -> [42, 42]; _x2 -> [43, 43]; _x3 -> [44, 44]}
 -----------------------------
 --- SAFE --------------------
Property : tmp2-tmp3 < 0
Invariant: {x -> t0[_x0], y -> t0[_x0], z -> t0[_x0], val -> t3[_x3], tmp1 -> t1[_x1], tmp2 -> t2[_x2], tmp3 -> t3[_x3], Mem1[4...7] -> t1[_x1], Mem2[4...7] -> t2[_x2], Mem3[4...7] -> t3[_x3]}{_x0 -> [4, 4]; _x1 -> [42, 42]; _x2 -> [43, 43]; _x3 -> [44, 44]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 8 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
entry={}
ret={x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t5[_x5], tmp1 -> t3[_x3], tmp2 -> t4[_x4], tmp3 -> t5[_x5], Mem1[4...7] -> t3[_x3], Mem2[5...8] -> t4[_x4], Mem3[6...9] -> t5[_x5]}{_x0 -> [4, 4]; _x1 -> [5, 5]; _x2 -> [6, 6]; _x3 -> [42, 42]; _x4 -> [43, 43]; _x5 -> [44, 44]}
Abstract trace: entry ret
 --- SAFE --------------------
Property : tmp1-tmp2 < 0
Invariant: {x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t5[_x5], tmp1 -> t3[_x3], tmp2 -> t4[_x4], tmp3 -> t5[_x5], Mem1[4...7] -> t3[_x3], Mem2[5...8] -> t4[_x4], Mem3[6...9] -> t5[_x5]}{_x0 -> [4, 4]; _x1 -> [5, 5]; _x2 -> [6, 6]; _x3 -> [42, 42]; _x4 -> [43, 43]; _x5 -> [44, 44]}
 -----------------------------
 --- SAFE --------------------
Property : tmp2-tmp3 < 0
Invariant: {x -> t0[_x0], y -> t1[_x1], z -> t2[_x2], val -> t5[_x5], tmp1 -> t3[_x3], tmp2 -> t4[_x4], tmp3 -> t5[_x5], Mem1[4...7] -> t3[_x3], Mem2[5...8] -> t4[_x4], Mem3[6...9] -> t5[_x5]}{_x0 -> [4, 4]; _x1 -> [5, 5]; _x2 -> [6, 6]; _x3 -> [42, 42]; _x4 -> [43, 43]; _x5 -> [44, 44]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 9 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
entry={}
ret={m1_lb -> t0[_x0], m1_ub -> t1[_x1], x -> t3[_x3], y -> t4[_x4], tmp1 -> t2[_x2], tmp2 -> t2[_x2], Mem1[20...23] -> t2[_x2], Mem1[24...27] -> t2[_x2], Mem1[28...31] -> t2[_x2], Mem1[32...35] -> t2[_x2], Mem1[36...39] -> t2[_x2], Mem1[40...43] -> t2[_x2], Mem1[44...47] -> t2[_x2], Mem1[48...51] -> t2[_x2], Mem1[52...55] -> t2[_x2], Mem1[56...59] -> t2[_x2], Mem1[60...63] -> t2[_x2], Mem1[64...67] -> t2[_x2], Mem1[68...71] -> t2[_x2], Mem1[72...75] -> t2[_x2], Mem1[76...79] -> t2[_x2], Mem1[80...83] -> t2[_x2]}{_x0 -> [20, 20]; _x1 -> [80, 80]; _x2 -> [42, 42]; _x3 -> [24, 24]; _x4 -> [76, 76]}
Abstract trace: entry ret
 --- SAFE --------------------
Property : tmp1-tmp2 = 0
Invariant: {m1_lb -> t0[_x0], m1_ub -> t1[_x1], x -> t3[_x3], y -> t4[_x4], tmp1 -> t2[_x2], tmp2 -> t2[_x2], Mem1[20...23] -> t2[_x2], Mem1[24...27] -> t2[_x2], Mem1[28...31] -> t2[_x2], Mem1[32...35] -> t2[_x2], Mem1[36...39] -> t2[_x2], Mem1[40...43] -> t2[_x2], Mem1[44...47] -> t2[_x2], Mem1[48...51] -> t2[_x2], Mem1[52...55] -> t2[_x2], Mem1[56...59] -> t2[_x2], Mem1[60...63] -> t2[_x2], Mem1[64...67] -> t2[_x2], Mem1[68...71] -> t2[_x2], Mem1[72...75] -> t2[_x2], Mem1[76...79] -> t2[_x2], Mem1[80...83] -> t2[_x2]}{_x0 -> [20, 20]; _x1 -> [80, 80]; _x2 -> [42, 42]; _x3 -> [24, 24]; _x4 -> [76, 76]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 10 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
CRAB WARNING: array expansion ignored array write with non-constant index i
bb0={}
bb2={Mem1[2...5] -> t0[_x0]}{_x0 -> [42, 42]}
bb3={Mem1[2...5] -> t0[_y0]}{_y0 -> [42, 42]}
bb4={x -> t0[_y1], Mem1[2...5] -> t0[_y1]}{_y1 -> [42, 42]}
bb1={Mem1[2...5] -> t0[_x0]}{_x0 -> [42, 42]}
Abstract trace: bb0 bb2 bb1 bb3 bb4
CRAB WARNING: array expansion ignored array write with non-constant index i
 --- WARNING -----------------
Property : x = 42
Invariant: {x -> t0[_y1], Mem1[2...5] -> t0[_y1]}{}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 11 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
CRAB WARNING: array expansion ignored array write with non-constant index i
bb0={}
bb2={Mem1[2...5] -> t0[_x0], Mem2[2...5] -> t1[_x1], Mem1[6...9] -> t2[_x2]}{_x0 -> [42, 42]; _x1 -> [666, 666]; _x2 -> [50, 50]}
bb3={i -> t0[_y3], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
bb4={i -> t0[_y3], x -> t1[_y0], y -> t3[_y2], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
bb1={Mem1[2...5] -> t0[_x0], Mem2[2...5] -> t1[_x1], Mem1[6...9] -> t2[_x2]}{_x0 -> [42, 42]; _x1 -> [666, 666]; _x2 -> [50, 50]}
Abstract trace: bb0 bb2 bb1 bb3 bb4
CRAB WARNING: array expansion ignored array write with non-constant index i
 --- SAFE --------------------
Property : x = 42
Invariant: {i -> t0[_y3], x -> t1[_y0], y -> t3[_y2], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
 -----------------------------
 --- SAFE --------------------
Property : y = 50
Invariant: {i -> t0[_y3], x -> t1[_y0], y -> t3[_y2], Mem1[2...5] -> t1[_y0], Mem2[2...5] -> t2[_y1], Mem1[6...9] -> t3[_y2]}{_y0 -> [42, 42]; _y1 -> [666, 666]; _y2 -> [50, 50]; _y3 -> [10, +oo]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 12 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
CRAB WARNING: Ignored read from cell Mem1[0...3] because it overlaps with 1 cells
CRAB WARNING: Ignored read from cell Mem1[4...7] because it overlaps with 2 cells
bb0={}
Abstract trace: bb0
 --- SAFE --------------------
Property : x = 42
Invariant: {x -> t0[_x0], y -> t1[_x1], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t1[_x1]}{_x0 -> [42, 42]; _x1 -> [50, 50]}
 -----------------------------
 --- SAFE --------------------
Property : y = 50
Invariant: {x -> t0[_x0], y -> t1[_x1], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t1[_x1]}{_x0 -> [42, 42]; _x1 -> [50, 50]}
 -----------------------------
 --- SAFE --------------------
Property : x = 666
Invariant: {i -> t2[_x2], j -> t3[_x3], x -> t4[_x4], y -> t4[_x4], Mem1[0...3] -> t4[_x4], Mem1[4...7] -> t4[_x4], Mem1[8...11] -> t4[_x4]}{_x2 -> [0, 0]; _x3 -> [8, 8]; _x4 -> [666, 666]}
 -----------------------------
 --- SAFE --------------------
Property : y = 666
Invariant: {i -> t2[_x2], j -> t3[_x3], x -> t4[_x4], y -> t4[_x4], Mem1[0...3] -> t4[_x4], Mem1[4...7] -> t4[_x4], Mem1[8...11] -> t4[_x4]}{_x2 -> [0, 0]; _x3 -> [8, 8]; _x4 -> [666, 666]}
 -----------------------------
CRAB WARNING: Ignored read from cell Mem1[0...3] because it overlaps with 1 cells
CRAB WARNING: Ignored read from cell Mem1[4...7] because it overlaps with 2 cells
 --- WARNING -----------------
Property : y = 666
Invariant: {i -> t1[_x5], j -> t3[_x3], Mem1[2...5] -> t2[_x6], Mem1[6...9] -> t2[_x6]}{_x3 -> [8, 8]; _x5 -> [2, 2]; _x6 -> [777, 777]}
 -----------------------------
 --- WARNING -----------------
Property : x = 666
Invariant: {i -> t1[_x5], j -> t3[_x3], y -> t4[_x7], Mem1[2...5] -> t2[_x6], Mem1[6...9] -> t2[_x6]}{_x3 -> [8, 8]; _x5 -> [2, 2]; _x6 -> [777, 777]; _x7 -> [666, 666]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
4  Number of total safe checks
0  Number of total error checks
2  Number of total warning checks
0  Number of total unreachable checks

===================================
 Test 13 for array expansion domain 
===================================
Invariants using ArrayExpansion(Term(Intervals))
bb0={}
Abstract trace: bb0
 --- SAFE --------------------
Property : x = 42
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t0[_x0], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [12, 12]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 0
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t5[_x5], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [12, 12]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 0
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t5[_x5], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [12, 12]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 0
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t5[_x5], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [12, 12]; _x5 -> [0, 0]}
 -----------------------------
 --- SAFE --------------------
Property : x = 50
Invariant: {i -> t3[_x3], j -> t4[_x4], x -> t2[_x2], Mem1[0...3] -> t0[_x0], Mem1[4...7] -> t5[_x5], Mem1[8...11] -> t5[_x5], Mem1[12...15] -> t5[_x5], Mem1[16...19] -> t2[_x2]}{_x0 -> [42, 42]; _x2 -> [50, 50]; _x3 -> [4, 4]; _x4 -> [12, 12]; _x5 -> [0, 0]}
 -----------------------------
user-defined assertion checker using ArrayExpansion(Term(Intervals))
5  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Program 1: forall 0<= i< 10. a[i] = 123456Invariants using ArrayGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
bb1_f=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
ret=({n1 -> [1, 1], i -> [10, 10], i-n1<=9, n1-i<=1},{[0,1)=>{A0 -> [123456, 123456]}, [0,2)=>{A0 -> [123456, 123456]}, [0,n1)=>{A0 -> [123456, 123456]}, [0,i)=>{A0 -> [123456, 123456]}, [1,2)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,2)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
bb1_t=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
bb2=({n1 -> [1, 1], i -> [0, 9], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 2: forall 0<= i< 10. a[i] = b[i] = x and x = 123456Invariants using ArrayGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}})
bb1_f=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}})
ret=({n1 -> [1, 1], i -> [10, 10], i-n1<=9, n1-i<=1},{[0,1)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [0,2)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [0,n1)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [0,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,2)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,2)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}})
bb1_t=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}})
bb2=({n1 -> [1, 1], i -> [0, 9], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]; B -> [123456, 123456]}})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 3: forall 0<= i< 10. a[i] = 8 and b[i] = 5Invariants using ArrayGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [8, 8]; B -> [5, 5]}, [1,i)=>{A -> [8, 8]; B -> [5, 5]}, [2,i)=>{A -> [8, 8]; B -> [5, 5]}, [n1,i)=>{A -> [8, 8]; B -> [5, 5]}})
bb1_f=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [8, 8]; B -> [5, 5]}, [1,i)=>{A -> [8, 8]; B -> [5, 5]}, [2,i)=>{A -> [8, 8]; B -> [5, 5]}, [n1,i)=>{A -> [8, 8]; B -> [5, 5]}})
ret=({n1 -> [1, 1], i -> [10, 10], i-n1<=9, n1-i<=1},{[0,1)=>{A -> [8, 8]; B -> [5, 5]}, [0,2)=>{A -> [8, 8]; B -> [5, 5]}, [0,n1)=>{A -> [8, 8]; B -> [5, 5]}, [0,i)=>{A -> [8, 8]; B -> [5, 5]}, [1,2)=>{A -> [8, 8]; B -> [5, 5]}, [1,i)=>{A -> [8, 8]; B -> [5, 5]}, [2,i)=>{A -> [8, 8]; B -> [5, 5]}, [n1,2)=>{A -> [8, 8]; B -> [5, 5]}, [n1,i)=>{A -> [8, 8]; B -> [5, 5]}})
bb1_t=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [8, 8]; B -> [5, 5]}, [1,i)=>{A -> [8, 8]; B -> [5, 5]}, [2,i)=>{A -> [8, 8]; B -> [5, 5]}, [n1,i)=>{A -> [8, 8]; B -> [5, 5]}})
bb2=({n1 -> [1, 1], i -> [0, 9], i-n1<=9, n1-i<=1},{[0,i)=>{A -> [8, 8]; B -> [5, 5]}, [1,i)=>{A -> [8, 8]; B -> [5, 5]}, [2,i)=>{A -> [8, 8]; B -> [5, 5]}, [n1,i)=>{A -> [8, 8]; B -> [5, 5]}})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 4: forall 0<= i < n. a[i] = 123456 (unbounded loop)Invariants using ArrayGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], n1-i<=1, i-n<=0},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]}})
bb1_f=({n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], n1-i<=1, i-n<=0},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]}})
ret=({n1 -> [1, 1], i -> [1, +oo], n -> [1, +oo], n1-i<=1, n-i<=0, i-n<=0},{[0,1)=>{A -> [123456, 123456]}, [0,n1)=>{A -> [123456, 123456]}, [0,i)=>{A -> [123456, 123456]}, [0,n)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [1,n)=>{A -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]}, [2,n)=>{A -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]}, [n1,n)=>{A -> [123456, 123456]}})
bb1_t=({n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], n1-i<=1, i-n<=0},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]}})
bb2=({n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], n1-i<=1, i-n<=-1, n1-n<=0},{[0,i)=>{A -> [123456, 123456]}, [1,i)=>{A -> [123456, 123456]}, [2,i)=>{A -> [123456, 123456]}, [n1,i)=>{A -> [123456, 123456]}})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 6: a[0] = 89 and for all 1<= i < n. a[i] = a[i-1]Invariants using ArrayGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], val -> [89, 89], n1-i<=0, i-n<=0},{[0,1)=>{A -> [89, 89]}, [0,n1)=>{A -> [89, 89]}, [0,i)=>{A -> [89, 89]}, [1,i)=>{A -> [89, 89]}, [2,i)=>{A -> [89, 89]}, [n1,i)=>{A -> [89, 89]}})
bb1_f=({n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], val -> [89, 89], n1-i<=0, i-n<=0},{[0,1)=>{A -> [89, 89]}, [0,n1)=>{A -> [89, 89]}, [0,i)=>{A -> [89, 89]}, [1,i)=>{A -> [89, 89]}, [2,i)=>{A -> [89, 89]}, [n1,i)=>{A -> [89, 89]}})
ret=({n1 -> [1, 1], i -> [2, +oo], n -> [2, +oo], val -> [89, 89], n1-i<=0, n-i<=0, i-n<=0},{[0,1)=>{A -> [89, 89]}, [0,2)=>{A -> [89, 89]}, [0,n1)=>{A -> [89, 89]}, [0,i)=>{A -> [89, 89]}, [0,n)=>{A -> [89, 89]}, [1,2)=>{A -> [89, 89]}, [1,i)=>{A -> [89, 89]}, [1,n)=>{A -> [89, 89]}, [2,i)=>{A -> [89, 89]}, [2,n)=>{A -> [89, 89]}, [n1,2)=>{A -> [89, 89]}, [n1,i)=>{A -> [89, 89]}, [n1,n)=>{A -> [89, 89]}})
bb1_t=({n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], val -> [89, 89], n1-i<=0, i-n<=0},{[0,1)=>{A -> [89, 89]}, [0,n1)=>{A -> [89, 89]}, [0,i)=>{A -> [89, 89]}, [1,i)=>{A -> [89, 89]}, [2,i)=>{A -> [89, 89]}, [n1,i)=>{A -> [89, 89]}})
bb2=({n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], val -> [89, 89], n1-i<=0, i-n<=-1, n1-n<=-1},{[0,1)=>{A -> [89, 89]}, [0,n1)=>{A -> [89, 89]}, [0,i)=>{A -> [89, 89]}, [1,i)=>{A -> [89, 89]}, [2,i)=>{A -> [89, 89]}, [n1,i)=>{A -> [89, 89]}})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 7: forall 0<= i< 10 and i % 2 = 0. a[i] = 123456Invariants using ArrayGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], i-n2<=9, n2-i<=2},{})
bb1_f=({n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], i-n2<=9, n2-i<=2},{})
ret=({n1 -> [1, 1], n2 -> [2, 2], i -> [10, 11], n -> [1, +oo], i-n2<=9, n2-i<=2},{})
bb1_t=({n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], i-n2<=9, n2-i<=2},{})
bb2=({n1 -> [1, 1], n2 -> [2, 2], i -> [0, 9], n -> [1, +oo], i-n2<=9, n2-i<=2},{})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 8: forall 0<= i < n. 1 <= a[i] <= 2Invariants using ArrayGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb1_f2=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb1_f=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,1)=>{A -> [2, 2]}, [i1,i2)=>{A -> [2, 2]}, [i1,n)=>{A -> [2, 2]}, [i2,1)=>{A -> [1, 1]}, [i2,i1)=>{A -> [1, 1]}, [i2,n)=>{A -> [1, 1]}})
ret=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,1)=>{A -> [2, 2]}, [i1,i2)=>{A -> [2, 2]}, [i1,n)=>{A -> [2, 2]}, [i2,1)=>{A -> [1, 1]}, [i2,i1)=>{A -> [1, 1]}, [i2,n)=>{A -> [1, 1]}})
bb1_f1=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb1_t=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb2=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=-1, i1-n<=-1},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb2b=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=-1, i1-n<=-1},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
bb3=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], val -> [1, 2], val-i2<=1, i2-n<=0, i1-n<=0},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,1)=>{A -> [2, 2]}, [i1,i2)=>{A -> [2, 2]}, [i2,1)=>{A -> [1, 1]}, [i2,i1)=>{A -> [1, 1]}})
bb2a=({i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], i2-n<=-1, i1-n<=-1},{[0,i1)=>{A -> [-oo, 2]}, [0,i2)=>{A -> [1, +oo]}, [1,i1)=>{A -> [-oo, 2]}, [1,i2)=>{A -> [1, +oo]}, [i1,i2)=>{A -> [2, 2]}, [i2,i1)=>{A -> [1, 1]}})
Abstract trace: entry (bb1 bb1_t bb2 bb2b bb2a bb3)^{4} bb1_f2 bb1_f1 bb1_f ret

Program 9: forall 0<= i < n. a[i] == 123456 (decrementing loop)Invariants using ArrayGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({i -> [-1, 9]},{})
bb1_f=({i -> [-1, 9]},{})
ret=({i -> [-1, -1]},{[0,5)=>{A -> [123456, 123456]}, [0,6)=>{A -> [123456, 123456]}, [0,9)=>{A -> [123456, 123456]}, [0,10)=>{A -> [123456, 123456]}, [5,6)=>{A -> [123456, 123456]}, [5,9)=>{A -> [123456, 123456]}, [5,10)=>{A -> [123456, 123456]}, [6,9)=>{A -> [123456, 123456]}, [6,10)=>{A -> [123456, 123456]}, [9,10)=>{A -> [123456, 123456]}})
bb1_t=({i -> [-1, 9]},{})
bb2=({i -> [0, 9]},{})
Abstract trace: entry (bb1 bb1_t bb2)^{5} bb1_f ret

Program 10: forall 0<= i < n. a[i] == 123456 (decrementing loop w/ temp vars)Invariants using ArrayGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({i -> [-1, 9]},{})
bb1_f=({i -> [-1, 9]},{})
ret=({i -> [-1, -1]},{[0,5)=>{A -> [123456, 123456]}, [0,6)=>{A -> [123456, 123456]}, [0,9)=>{A -> [123456, 123456]}, [0,10)=>{A -> [123456, 123456]}, [5,6)=>{A -> [123456, 123456]}, [5,9)=>{A -> [123456, 123456]}, [5,10)=>{A -> [123456, 123456]}, [6,9)=>{A -> [123456, 123456]}, [6,10)=>{A -> [123456, 123456]}, [9,10)=>{A -> [123456, 123456]}})
bb1_t=({i -> [-1, 9]},{})
bb2=({i -> [0, 9]},{})
Abstract trace: entry (bb1 bb1_t bb2)^{5} bb1_f ret

Program 11: forall 0<= i< 10. a[i] = 123456 (w/ temp vars)Invariants using ArrayGraph(SplitDBM,Intervals)
entry=({},{})
bb1=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
bb1_f=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
ret=({n1 -> [1, 1], i -> [10, 10], i-n1<=9, n1-i<=1},{[0,1)=>{A0 -> [123456, 123456]}, [0,2)=>{A0 -> [123456, 123456]}, [0,n1)=>{A0 -> [123456, 123456]}, [0,i)=>{A0 -> [123456, 123456]}, [1,2)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,2)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
bb1_t=({n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
bb2=({n1 -> [1, 1], i -> [0, 9], i-n1<=9, n1-i<=1},{[0,i)=>{A0 -> [123456, 123456]}, [1,i)=>{A0 -> [123456, 123456]}, [2,i)=>{A0 -> [123456, 123456]}, [n1,i)=>{A0 -> [123456, 123456]}})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Program 12: forall 0<= i < n. is_not_null(a[i]) &&  is_not_null(b[i]) 
Invariants using ArrayGraph(Product(SplitDBM,Nullity),Nullity)
entry=(({}, {}),{})
bb1=(({i -> [0, +oo], n -> [1, +oo], max -> [0, +oo], max-n<=-1, i-n<=0, n-max<=1, i-max<=1}, {obj1 -> NN}),{[0,max)=>{A -> NN}, [1,max)=>{A -> NN}, [i,max)=>{A -> NN}})
bb1_f=(({i -> [0, +oo], n -> [1, +oo], max -> [0, +oo], max-n<=-1, i-n<=0, n-max<=1, i-max<=1}, {obj1 -> NN}),{[0,max)=>{A -> NN}, [1,max)=>{A -> NN}, [i,max)=>{A -> NN}})
ret=(({i -> [1, +oo], n -> [1, +oo], max -> [0, +oo], max-i<=-1, n-i<=0, max-n<=-1, i-n<=0, n-max<=1, i-max<=1}, {obj1 -> NN}),{[0,max)=>{A -> NN}, [1,max)=>{A -> NN}})
bb1_t=(({i -> [0, +oo], n -> [1, +oo], max -> [0, +oo], max-n<=-1, i-n<=0, n-max<=1, i-max<=1}, {obj1 -> NN}),{[0,max)=>{A -> NN}, [1,max)=>{A -> NN}, [i,max)=>{A -> NN}})
bb2=(({i -> [0, +oo], n -> [1, +oo], max -> [0, +oo], max-n<=-1, i-n<=-1, n-max<=1, i-max<=0}, {obj1 -> NN}),{[0,i)=>{A -> NN}, [0,max)=>{A -> NN}, [1,i)=>{A -> NN}, [1,max)=>{A -> NN}, [i,max)=>{A -> NN}})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 1: forall 0<= i< 10. a[i] = 123456
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, 10]; A0 -> [0, 0] | [123456, 123456]; A0_prop -> [0, 0]}
bb1_f={n1 -> [1, 1]; i -> [0, 10]; A0 -> [0, 0] | [123456, 123456]; A0_prop -> [0, 0]}
ret={n1 -> [1, 1]; i -> [10, 10]; A0 -> [0, 0] | [123456, 123456]; A0_prop -> [0, 0]}
bb1_t={n1 -> [1, 1]; i -> [0, 10]; A0 -> [0, 0] | [123456, 123456]; A0_prop -> [0, 0]}
bb2={n1 -> [1, 1]; i -> [0, 9]; A0 -> [0, 0] | [123456, 123456]; A0_prop -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, 10], A0 -> [0, 123456], A0_prop -> [0, 0], i-n1<=9, n1-i<=1, A0-i<=123455}
bb1_f={n1 -> [1, 1], i -> [0, 10], A0 -> [0, 123456], A0_prop -> [0, 0], i-n1<=9, n1-i<=1, A0-i<=123455}
ret={n1 -> [1, 1], i -> [10, 10], A0 -> [0, 123456], A0_prop -> [0, 0], i-n1<=9, n1-i<=1, A0-i<=123455}
bb1_t={n1 -> [1, 1], i -> [0, 10], A0 -> [0, 123456], A0_prop -> [0, 0], i-n1<=9, n1-i<=1, A0-i<=123455}
bb2={n1 -> [1, 1], i -> [0, 9], A0 -> [0, 123456], A0_prop -> [0, 0], i-n1<=9, n1-i<=1, A0-i<=123455}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 2: forall 0<= i< 10. a[i] = b[i] = x and x = 123456
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]; B -> [0, 0] | [123456, 123456]}
bb1_f={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]; B -> [0, 0] | [123456, 123456]}
ret={n1 -> [1, 1]; i -> [10, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]; B -> [0, 0] | [123456, 123456]}
bb1_t={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]; B -> [0, 0] | [123456, 123456]}
bb2={n1 -> [1, 1]; i -> [0, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]; B -> [0, 0] | [123456, 123456]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], B -> [0, 123456], i-n1<=9, n1-i<=1, A-i<=123455, B-i<=123455}
bb1_f={n1 -> [1, 1], i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], B -> [0, 123456], i-n1<=9, n1-i<=1, A-i<=123455, B-i<=123455}
ret={n1 -> [1, 1], i -> [10, 10], A -> [0, 123456], A_p -> [0, 0], B -> [0, 123456], i-n1<=9, n1-i<=1, A-i<=123455, B-i<=123455}
bb1_t={n1 -> [1, 1], i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], B -> [0, 123456], i-n1<=9, n1-i<=1, A-i<=123455, B-i<=123455}
bb2={n1 -> [1, 1], i -> [0, 9], A -> [0, 123456], A_p -> [0, 0], B -> [0, 123456], i-n1<=9, n1-i<=1, A-i<=123455, B-i<=123455}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 3: forall 0<= i< 10. a[i] = 8 and b[i] = 5
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [8, 8]; A_p -> [0, 0]; B -> [0, 0] | [5, 5]}
bb1_f={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [8, 8]; A_p -> [0, 0]; B -> [0, 0] | [5, 5]}
ret={n1 -> [1, 1]; i -> [10, 10]; A -> [0, 0] | [8, 8]; A_p -> [0, 0]; B -> [0, 0] | [5, 5]}
bb1_t={n1 -> [1, 1]; i -> [0, 10]; A -> [0, 0] | [8, 8]; A_p -> [0, 0]; B -> [0, 0] | [5, 5]}
bb2={n1 -> [1, 1]; i -> [0, 9]; A -> [0, 0] | [8, 8]; A_p -> [0, 0]; B -> [0, 0] | [5, 5]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, 10], A -> [0, 8], A_p -> [0, 0], B -> [0, 5], i-n1<=9, n1-i<=1, A-i<=7, B-i<=4}
bb1_f={n1 -> [1, 1], i -> [0, 10], A -> [0, 8], A_p -> [0, 0], B -> [0, 5], i-n1<=9, n1-i<=1, A-i<=7, B-i<=4}
ret={n1 -> [1, 1], i -> [10, 10], A -> [0, 8], A_p -> [0, 0], B -> [0, 5], i-n1<=9, n1-i<=1, A-i<=7, B-i<=4}
bb1_t={n1 -> [1, 1], i -> [0, 10], A -> [0, 8], A_p -> [0, 0], B -> [0, 5], i-n1<=9, n1-i<=1, A-i<=7, B-i<=4}
bb2={n1 -> [1, 1], i -> [0, 9], A -> [0, 8], A_p -> [0, 0], B -> [0, 5], i-n1<=9, n1-i<=1, A-i<=7, B-i<=4}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 4: forall 0<= i < n. a[i] = 123456 (unbounded loop)
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_f={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
ret={n1 -> [1, 1]; i -> [1, +oo]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_t={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb2={n1 -> [1, 1]; i -> [0, +oo]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], n1-i<=1, A-i<=123455, i-n<=0, A-n<=123455}
bb1_f={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], n1-i<=1, A-i<=123455, i-n<=0, A-n<=123455}
ret={n1 -> [1, 1], i -> [1, +oo], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], n1-i<=1, A-i<=123455, n-i<=0, i-n<=0, A-n<=123455}
bb1_t={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], n1-i<=1, A-i<=123455, i-n<=0, A-n<=123455}
bb2={n1 -> [1, 1], i -> [0, +oo], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], n1-i<=1, A-i<=123455, i-n<=-1, A-n<=123454, n1-n<=0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 5: for all 0<= i< 10. a[i] = 123456 (assume elem size of 4 bytes)
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_f={i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
ret={i -> [10, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_t={i -> [0, 10]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb2={i -> [0, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], A-i<=123455}
bb1_f={i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], A-i<=123455}
ret={i -> [10, 10], A -> [0, 123456], A_p -> [0, 0], A-i<=123455}
bb1_t={i -> [0, 10], A -> [0, 123456], A_p -> [0, 0], A-i<=123455}
bb2={i -> [0, 9], A -> [0, 123456], A_p -> [0, 0], A-i<=123455}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 6: a[0] = 89 and for all 1<= i < n. a[i] = a[i-1]
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A -> [0, 0] | [89, 89]; A_p -> [0, 0]; val -> [89, 89]}
bb1_f={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A -> [0, 0] | [89, 89]; A_p -> [0, 0]; val -> [89, 89]}
ret={n1 -> [1, 1]; i -> [2, +oo]; n -> [2, +oo]; A -> [0, 0] | [89, 89]; A_p -> [0, 0]; val -> [89, 89]}
bb1_t={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A -> [0, 0] | [89, 89]; A_p -> [0, 0]; val -> [89, 89]}
bb2={n1 -> [1, 1]; i -> [1, +oo]; n -> [2, +oo]; A -> [0, 0] | [89, 89]; A_p -> [0, 0]; val -> [89, 89]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A -> [0, 89], A_p -> [0, 0], val -> [89, 89], n1-i<=0, i-n<=0}
bb1_f={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A -> [0, 89], A_p -> [0, 0], val -> [89, 89], n1-i<=0, i-n<=0}
ret={n1 -> [1, 1], i -> [2, +oo], n -> [2, +oo], A -> [0, 89], A_p -> [0, 0], val -> [89, 89], n1-i<=0, n-i<=0, i-n<=0}
bb1_t={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A -> [0, 89], A_p -> [0, 0], val -> [89, 89], n1-i<=0, i-n<=0}
bb2={n1 -> [1, 1], i -> [1, +oo], n -> [2, +oo], A -> [0, 89], A_p -> [0, 0], val -> [89, 89], n1-i<=0, i-n<=-1, n1-n<=-1}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 7: forall 0<= i< 10 and i % 2 = 0. a[i] = 123456
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 11]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_f={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 11]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
ret={n1 -> [1, 1]; n2 -> [2, 2]; i -> [10, 11]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_t={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 11]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb2={n1 -> [1, 1]; n2 -> [2, 2]; i -> [0, 0] | [2, 2] | [4, 4] | [6, 6] | [8, 9]; n -> [1, +oo]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], i-n2<=9, n2-i<=2, A-i<=123454}
bb1_f={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], i-n2<=9, n2-i<=2, A-i<=123454}
ret={n1 -> [1, 1], n2 -> [2, 2], i -> [10, 11], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], i-n2<=9, n2-i<=2, A-i<=123454}
bb1_t={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 11], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], i-n2<=9, n2-i<=2, A-i<=123454}
bb2={n1 -> [1, 1], n2 -> [2, 2], i -> [0, 9], n -> [1, +oo], A -> [0, 123456], A_p -> [0, 0], i-n2<=9, n2-i<=2, A-i<=123454}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 8: forall 0<= i < n. 1 <= a[i] <= 2
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb1_f2={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb1_f={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
ret={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb1_f1={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb1_t={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb2={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb2b={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
bb2a={n1 -> [1, 1]; i1 -> [0, +oo]; i2 -> [0, +oo]; n -> [1, +oo]; A -> [0, 2]; A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2 bb2b bb2a)^{3} bb1_f2 bb1_f1 bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, A-n<=1, i2-n<=0, i1-n<=0, n1-n<=0}
bb1_f2={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, A-n<=1, i2-n<=0, i1-n<=0, n1-n<=0}
bb1_f={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, A-n<=1, i2-n<=0, i1-n<=0, n1-n<=0}
ret={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, A-n<=1, i2-n<=0, i1-n<=0, n1-n<=0}
bb1_f1={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, A-n<=1, i2-n<=0, i1-n<=0, n1-n<=0}
bb1_t={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, A-n<=1, i2-n<=0, i1-n<=0, n1-n<=0}
bb2={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, A-n<=0, i2-n<=-1, i1-n<=-1, n1-n<=0}
bb2b={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, A-n<=0, i2-n<=-1, i1-n<=-1, n1-n<=0}
bb2a={n1 -> [1, 1], i1 -> [0, +oo], i2 -> [0, +oo], n -> [1, +oo], A -> [0, 2], A_p -> [0, 0], n1-i1<=1, A-i1<=2, A-i2<=1, n1-i2<=1, A-n<=0, i2-n<=-1, i1-n<=-1, n1-n<=0}
Abstract trace: entry (bb1 bb1_t bb2 bb2b bb2a)^{3} bb1_f2 bb1_f1 bb1_f ret

Program 9: forall 0<= i < n. a[i] == 123456 (decrementing loop)
Invariants using ArraySmashing(DisjunctiveIntervals)
entry={}
bb1={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_f={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
ret={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, -1]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb1_t={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [-1, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
bb2={n0 -> [0, 0]; n1 -> [1, 1]; n9 -> [9, 9]; i -> [0, 9]; A -> [0, 0] | [123456, 123456]; A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, 9], A -> [0, 123456], A_p -> [0, 0]}
bb1_f={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, 9], A -> [0, 123456], A_p -> [0, 0]}
ret={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, -1], A -> [0, 123456], A_p -> [0, 0]}
bb1_t={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [-1, 9], A -> [0, 123456], A_p -> [0, 0]}
bb2={n0 -> [0, 0], n1 -> [1, 1], n9 -> [9, 9], i -> [0, 9], A -> [0, 123456], A_p -> [0, 0]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 10: forall 0<= i < n. is_not_null(a[i]) &&  is_not_null(b[i]) 
Invariants using ArraySmashing(Product(SplitDBM,Nullity))
entry=({}, {})
bb1=({i -> [0, +oo], n -> [1, +oo], i-n<=0}, {A -> NN; B -> NN; obj1 -> NN})
bb1_f=({i -> [0, +oo], n -> [1, +oo], i-n<=0}, {A -> NN; B -> NN; obj1 -> NN})
ret=({i -> [1, +oo], n -> [1, +oo], n-i<=0, i-n<=0}, {A -> NN; B -> NN; obj1 -> NN})
bb1_t=({i -> [0, +oo], n -> [1, +oo], i-n<=0}, {A -> NN; B -> NN; obj1 -> NN})
bb2=({i -> [0, +oo], n -> [1, +oo], i-n<=-1}, {A -> NN; B -> NN; obj1 -> NN})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 11: forall 0<= i< 10. a[i] = true and b[i] = false
Invariants using ArraySmashing(Product(Boolean,SparseDBM))
entry=({}, {})
bb1=({A -> true; B -> false; TRUE -> true; FALSE -> false}, {n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1})
bb1_f=({A -> true; B -> false; TRUE -> true; FALSE -> false}, {n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1})
ret=({A -> true; B -> false; TRUE -> true; FALSE -> false}, {n1 -> [1, 1], i -> [10, 10], i-n1<=9, n1-i<=-9})
bb1_t=({A -> true; B -> false; TRUE -> true; FALSE -> false}, {n1 -> [1, 1], i -> [0, 10], i-n1<=9, n1-i<=1})
bb2=({A -> true; B -> false; TRUE -> true; FALSE -> false}, {n1 -> [1, 1], i -> [0, 9], i-n1<=8, n1-i<=1})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Program 12 (Memory SSA): forall 0<= i< 10. a[i] >=0 and a[i] <= 123456
Invariants using ArraySmashing(SplitDBM)
entry={}
bb1={i -> [0, 10], A0 -> [0, 0], A1 -> [0, 123456], A1-i<=123455}
bb1_f={i -> [0, 10], A0 -> [0, 0], A1 -> [0, 123456], A1-i<=123455}
bb3={i -> [10, 10], A0 -> [0, 0], A1 -> [0, 123456], A1-i<=123455}
ret={i -> [10, 10], A0 -> [0, 0], A1 -> [0, 123456], A3 -> [0, 123456], A4 -> [0, 500000], x -> [0, 123456], A1-i<=123446, A3-i<=123446, x-i<=123446, A4-i<=499990, A3-A1<=0, x-A1<=0, A4-A1<=500000, A1-A3<=0, A4-A3<=500000, A3-A4<=0, A1-A4<=0, A1-x<=0}
bb1_t={i -> [0, 10], A0 -> [0, 0], A1 -> [0, 123456], A1-i<=123455}
bb2={i -> [0, 9], A0 -> [0, 0], A1 -> [0, 123456], A1-i<=123455}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f bb3 ret

entry:
  goto bb1,bb2;
bb1:
  assume(-x <= 0);
  y = x;
  goto bb3;
bb3:
  assume(-y <= -1);
  assert(x != 0);

bb2:
  assume(x <= -1);
  tmp = 0;
  y = tmp-x;
  goto bb3;

Invariants using ElinaOctagon
entry={}
bb2={}
bb3={x-y <= 0; -x-y <= 0; -y <= 0}
bb1={}
 --- SAFE --------------------
Property : x != 0
Invariant: {x-y <= 0; -x-y <= 0; -y <= -1}
Note: it was proven by the forward+backward analysis
 -----------------------------
user-defined assertion checker using ElinaOctagon
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  goto bb1,bb2;
bb1:
  assume(-x <= -1);
  y = x;
  goto bb3;
bb3:
  assume(-y <= -6);
  assert(x <= 5);
  assert(-x <= 5);

bb2:
  assume(x <= 0);
  tmp = 0;
  y = tmp-x;
  goto bb3;

Invariants using ElinaOctagon
entry={}
bb2={}
bb3={x-y <= 0; -x-y <= 0; -y <= 0}
bb1={}
 --- WARNING -----------------
Property : x <= 5
Invariant: {x-y <= 0; -x-y <= 0; -y <= -6}
 -----------------------------
 --- WARNING -----------------
Property : -x <= 5
Invariant: {x <= 5; x-y <= -1; -x-y <= 0; -y <= -6}
 -----------------------------
user-defined assertion checker using ElinaOctagon
0  Number of total safe checks
0  Number of total error checks
2  Number of total warning checks
0  Number of total unreachable checks

Invariants using Boxes
entry={}
bb2={}
bb3={-x <= -1; -y <= -1} or 
{x <= 0; -tmp <= 0; tmp <= 0; -y <= 0}
bb1={}
 --- WARNING -----------------
Property : x <= 5
Invariant: {-x <= -1; -y <= -6} or 
{x <= 0; -tmp <= 0; tmp <= 0; -y <= -6}
 -----------------------------
 --- WARNING -----------------
Property : -x <= 5
Invariant: {-x <= -1; x <= 5; -y <= -6} or 
{x <= 0; -tmp <= 0; tmp <= 0; -y <= -6}
 -----------------------------
user-defined assertion checker using Boxes
0  Number of total safe checks
0  Number of total error checks
2  Number of total warning checks
0  Number of total unreachable checks

bb1:
  x = 0;
  y = 0;
  goto bb2;
bb2:
  goto bb3,bb4;
bb3:
  assume(x <= 99);
  x = x+1;
  y = y+1;
  goto bb2;
bb4:
  assume(-x <= -100);
  assert(y <= 100);


Invariants using ElinaOctagon
bb1={}
bb2={-x <= 0; x <= 100; x-y <= 0; -x-y <= 0; -y <= 0; x+y <= 200; -x+y <= 0; y <= 100}
bb4={-x <= 0; x <= 100; x-y <= 0; -x-y <= 0; -y <= 0; x+y <= 200; -x+y <= 0; y <= 100}
bb3={-x <= 0; x <= 100; x-y <= 0; -x-y <= 0; -y <= 0; x+y <= 200; -x+y <= 0; y <= 100}
 --- SAFE --------------------
Property : y <= 100
Invariant: {-x <= -100; x <= 100; x-y <= 0; -x-y <= -200; -y <= -100; x+y <= 200; -x+y <= 0; y <= 100}
Note: it was proven by the forward+backward analysis
 -----------------------------
user-defined assertion checker using ElinaOctagon
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

bb1:
  x = 0;
  goto bb2;
bb2:
  goto bb3,bb4;
bb3:
  assume(x <= 99);
  x = x+1;
  goto bb2;
bb4:
  assume(-x <= -100);
  assert(x <= 100);


Invariants using ElinaOctagon
bb1={}
bb2={-x <= 0; x <= 100}
bb4={-x <= 0}
bb3={-x <= 0}
 --- SAFE --------------------
Property : x <= 100
Invariant: {-x <= -100}
Note: it was proven by the forward+backward analysis
 -----------------------------
user-defined assertion checker using ElinaOctagon
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Invariants using Boxes
bb1={}
bb2={-x <= 0; x <= 100}
bb4={-x <= 0}
bb3={-x <= 0}
 --- SAFE --------------------
Property : x <= 100
Invariant: {-x <= -100}
Note: it was proven by the forward+backward analysis
 -----------------------------
user-defined assertion checker using Boxes
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  x = array_load(M,0,sz=4);
  goto bb1,bb2;
bb1:
  assume(-x <= 0);
  array_store(M,4,x,sz=4);
  goto bb3;
bb3:
  y = array_load(M,4,sz=4);
  assume(-y <= -1);
  assert(x != 0);

bb2:
  assume(x <= -1);
  tmp = 0;
  y = tmp-x;
  array_store(M,4,y,sz=4);
  goto bb3;

Invariants using ArrayExpansion(Intervals)
entry={}
bb2={}
bb3={M[4...7] -> [0, +oo]}
bb1={}
 --- SAFE --------------------
Property : x != 0
Invariant: {y -> [1, +oo]; M[4...7] -> [0, +oo]}
Note: it was proven by the forward+backward analysis
 -----------------------------
user-defined assertion checker using ArrayExpansion(Intervals)
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  x = 0;
  goto header1;
header1:
  goto body1,exit1;
body1:
  x = x+y;
  goto header1;
exit1:
  goto ifxpos,ret;
ifxpos:
  assume(-x <= -1);
  goto header2;
header2:
  goto body2,exit2;
body2:
  y = y+x;
  goto header2;
exit2:
  assert(-y <= 0);
  goto ret;
ret:


Invariants using ElinaOctagon
entry={}
header1={}
exit1={}
ret={}
ifxpos={}
header2={-x <= -1}
exit2={-x <= -1}
body2={-x <= -1}
body1={}
 --- WARNING -----------------
Property : -y <= 0
Invariant: {-x <= -1}
 -----------------------------
user-defined assertion checker using ElinaOctagon
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

entry:
  k = 0;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  i = i+1;
  k = k+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Boxes
entry={}
bb1={-k <= -15; -i <= -14; i <= 100} or 
{-k <= -14; k <= 14; -i <= -14; i <= 14} or 
{-k <= -13; k <= 13; -i <= -13; i <= 13} or 
{-k <= -12; k <= 12; -i <= -12; i <= 12} or 
{-k <= -11; k <= 11; -i <= -11; i <= 11} or 
{-k <= -10; k <= 10; -i <= -10; i <= 10} or 
{-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
bb1_f={-k <= -15; -i <= -14; i <= 100} or 
{-k <= -14; k <= 14; -i <= -14; i <= 14} or 
{-k <= -13; k <= 13; -i <= -13; i <= 13} or 
{-k <= -12; k <= 12; -i <= -12; i <= 12} or 
{-k <= -11; k <= 11; -i <= -11; i <= 11} or 
{-k <= -10; k <= 10; -i <= -10; i <= 10} or 
{-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
ret={-k <= -15; -i <= -100; i <= 100}
bb1_t={-k <= -15; -i <= -14; i <= 100} or 
{-k <= -14; k <= 14; -i <= -14; i <= 14} or 
{-k <= -13; k <= 13; -i <= -13; i <= 13} or 
{-k <= -12; k <= 12; -i <= -12; i <= 12} or 
{-k <= -11; k <= 11; -i <= -11; i <= 11} or 
{-k <= -10; k <= 10; -i <= -10; i <= 10} or 
{-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
Abstract trace: entry (bb1 bb1_t)^{13} bb1_f ret

loop1_entry:
  i = 0;
  k = 30;
  goto loop1_bb1;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(i <= 9);
  i = i+1;
  goto loop1_bb1;
loop1_bb1_f:
  assume(-i <= -10);
  j = 0;
  goto loop2_bb1;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(j <= 9);
  j = j+1;
  goto loop2_bb1;
loop2_bb1_f:
  assume(-j <= -10);
  goto ret;
ret:


Invariants using Boxes
loop1_entry={}
loop1_bb1={-k <= -30; k <= 30; -i <= 0; i <= 10}
loop1_bb1_f={-k <= -30; k <= 30; -i <= 0; i <= 10}
loop2_bb1={-k <= -30; k <= 30; -i <= -10; i <= 10; -j <= 0; j <= 10}
loop2_bb1_f={-k <= -30; k <= 30; -i <= -10; i <= 10; -j <= 0; j <= 10}
ret={-k <= -30; k <= 30; -i <= -10; i <= 10; -j <= -10; j <= 10}
loop2_bb1_t={-k <= -30; k <= 30; -i <= -10; i <= 10; -j <= 0; j <= 10}
loop1_bb1_t={-k <= -30; k <= 30; -i <= 0; i <= 10}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{11} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{11} loop2_bb1_f ret

entry:
  i = 0;
  goto loop1_head;
loop1_head:
  goto loop1_t,loop1_f;
loop1_t:
  assume(i <= 10);
  goto loop1_body;
loop1_body:
  i = i+1;
  goto loop1_body_t,loop1_body_f;
loop1_body_t:
  assume(-i <= -9);
  i = 0;
  goto loop1_body_x;
loop1_body_x:
  goto loop1_head;
loop1_body_f:
  assume(i <= 8);
  goto loop1_body_x;
loop1_f:
  assume(-i <= -11);
  goto loop2_head;
loop2_head:
  goto loop2_t,loop2_f;
loop2_t:
  assume(i <= 100);
  i = i-1;
  goto loop2_head;
loop2_f:
  assume(-i <= -101);
  goto ret;
ret:


Invariants using Boxes
entry={}
loop1_head={-i <= 0; i <= 8}
loop1_f={-i <= 0; i <= 8}
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop1_t={-i <= 0; i <= 8}
loop1_body={-i <= 0; i <= 8}
loop1_body_f={-i <= -1; i <= 9}
loop1_body_x={-i <= 0; i <= 8}
loop1_body_t={-i <= -1; i <= 9}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{9} loop1_f (loop2_head loop2_t)^{1} loop2_f ret

entry:
  i = 0;
  p = 0;
  goto loop_head;
loop_head:
  goto loop_t,loop_f;
loop_t:
  assume(i <= 9);
  i = i+1;
  p = p+4;
  goto loop_head;
loop_f:
  assume(-i <= -10);
  goto ret;
ret:


Invariants using Boxes
entry={}
loop_head={-i <= -10; i <= 10; -p <= -40; p <= 40} or 
{-i <= -9; i <= 9; -p <= -36; p <= 36} or 
{-i <= -8; i <= 8; -p <= -32; p <= 32} or 
{-i <= -7; i <= 7; -p <= -28; p <= 28} or 
{-i <= -6; i <= 6; -p <= -24; p <= 24} or 
{-i <= -5; i <= 5; -p <= -20; p <= 20} or 
{-i <= -4; i <= 4; -p <= -16; p <= 16} or 
{-i <= -3; i <= 3; -p <= -12; p <= 12} or 
{-i <= -2; i <= 2; -p <= -8; p <= 8} or 
{-i <= -1; i <= 1; -p <= -4; p <= 4} or 
{-i <= 0; i <= 0; -p <= 0; p <= 0}
loop_f={-i <= -10; i <= 10; -p <= -40; p <= 40} or 
{-i <= -9; i <= 9; -p <= -36; p <= 36} or 
{-i <= -8; i <= 8; -p <= -32; p <= 32} or 
{-i <= -7; i <= 7; -p <= -28; p <= 28} or 
{-i <= -6; i <= 6; -p <= -24; p <= 24} or 
{-i <= -5; i <= 5; -p <= -20; p <= 20} or 
{-i <= -4; i <= 4; -p <= -16; p <= 16} or 
{-i <= -3; i <= 3; -p <= -12; p <= 12} or 
{-i <= -2; i <= 2; -p <= -8; p <= 8} or 
{-i <= -1; i <= 1; -p <= -4; p <= 4} or 
{-i <= 0; i <= 0; -p <= 0; p <= 0}
ret={-i <= -10; i <= 10; -p <= -40; p <= 40}
loop_t={-i <= -10; i <= 10; -p <= -40; p <= 40} or 
{-i <= -9; i <= 9; -p <= -36; p <= 36} or 
{-i <= -8; i <= 8; -p <= -32; p <= 32} or 
{-i <= -7; i <= 7; -p <= -28; p <= 28} or 
{-i <= -6; i <= 6; -p <= -24; p <= 24} or 
{-i <= -5; i <= 5; -p <= -20; p <= 20} or 
{-i <= -4; i <= 4; -p <= -16; p <= 16} or 
{-i <= -3; i <= 3; -p <= -12; p <= 12} or 
{-i <= -2; i <= 2; -p <= -8; p <= 8} or 
{-i <= -1; i <= 1; -p <= -4; p <= 4} or 
{-i <= 0; i <= 0; -p <= 0; p <= 0}
Abstract trace: entry (loop_head loop_t)^{11} loop_f ret

entry:
  k = 0;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i != 9);
  goto bb2;
bb2:
  i = i+1;
  k = k+1;
  goto bb1;
bb1_f:
  assume(i = 9);
  goto ret;
ret:


Invariants using Boxes
entry={}
bb1={-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
bb1_f={-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
ret={-k <= -9; k <= 9; -i <= -9; i <= 9}
bb1_t={-k <= -9; k <= 9; -i <= -9; i <= 9} or 
{-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
bb2={-k <= -8; k <= 8; -i <= -8; i <= 8} or 
{-k <= -7; k <= 7; -i <= -7; i <= 7} or 
{-k <= -6; k <= 6; -i <= -6; i <= 6} or 
{-k <= -5; k <= 5; -i <= -5; i <= 5} or 
{-k <= -4; k <= 4; -i <= -4; i <= 4} or 
{-k <= -3; k <= 3; -i <= -3; i <= 3} or 
{-k <= -2; k <= 2; -i <= -2; i <= 2} or 
{-k <= -1; k <= 1; -i <= -1; i <= 1} or 
{-k <= 0; k <= 0; -i <= 0; i <= 0}
Abstract trace: entry (bb1 bb1_t bb2)^{10} bb1_f ret

entry:
  x = 1;
  y = 0;
  goto header;
header:
  goto body,exit;
body:
  x = x+y;
  y = y+1;
  goto header;
exit:
  assert(-x+y <= 0);


Invariants using Boxes
entry={}
header={-x <= -2; -y <= -1} or 
{-x <= -1; x <= 1; -y <= 0}
exit={-x <= -2; -y <= -1} or 
{-x <= -1; x <= 1; -y <= 0}
body={-x <= -2; -y <= -1} or 
{-x <= -1; x <= 1; -y <= 0}
Abstract trace: entry (header body)^{4} exit

Testing some boxes operations ...
{-y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-y <= -3; y <= 3; -z <= -4; z <= 4}
x:=y + z= 
{-x <= -11; x <= 13; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= -7; x <= 9; -y <= -3; y <= 3; -z <= -4; z <= 4}
x:=y - z= 
{-x <= 0; x <= 2; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= 1; x <= -1; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= 1; x <= -1; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= 4; x <= -2; -y <= -3; y <= 3; -z <= -4; z <= 4}
x:=y * z= 
{-x <= -12; x <= 42; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -12; x <= 42; -y <= -3; y <= 3; -z <= -4; z <= 4}
x:=y / z= 
{-x <= 0; x <= 1; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= 0; x <= 1; -y <= -3; y <= 3; -z <= -4; z <= 4}
INV: {-x <= -11; x <= 13; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= -7; x <= 9; -y <= -3; y <= 3; -z <= -4; z <= 4}
ADDED x >= y 
{-x <= -11; x <= 13; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= -7; x <= 9; -y <= -3; y <= 3; -z <= -4; z <= 4}
INV: {-x <= -11; x <= 13; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= -7; x <= 9; -y <= -3; y <= 3; -z <= -4; z <= 4}
ADDED x <= y + z -1
{-x <= -11; x <= 12; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -6; y <= 6; -z <= -7; z <= 7} or 
{-x <= -10; x <= 10; -y <= -3; y <= 3; -z <= -4; z <= 4} or 
{-x <= -7; x <= 9; -y <= -3; y <= 3; -z <= -4; z <= 4}
INV: {}
ADDED x != 9
{-x <= -10} or 
{x <= 8}
ADDED y >= 9
{-x <= -10; -y <= -9} or 
{x <= 8; -y <= -9}
ADDED y <= 9
{-x <= -10; -y <= -9; y <= 9} or 
{x <= 8; -y <= -9; y <= 9}
ADDED z > 9
{-x <= -10; -y <= -9; y <= 9; -z <= -10} or 
{x <= 8; -y <= -9; y <= 9; -z <= -10}
ADDED z < 9
_|_
OP1={-x <= -2; -y <= -2; y <= 2} or 
{-x <= -1; x <= 1; -y <= -1; y <= 1} or 
{-x <= -1; x <= 1; -y <= 0; y <= 0}
OP2={-x < -3; -y <= -3; y <= 3} or 
{-x <= -2; x <= 3; -y <= -3; y <= 3} or 
{-x <= -2; x <= 3; -y <= -2; y <= 2} or 
{-x <= -2; x <= 3; -y <= -1; y <= 1} or 
{-x < -1; x < 2; -y <= -2; y <= 2} or 
{-x < -1; x < 2; -y <= -1; y <= 1} or 
{-x <= -1; x <= 1; -y <= -2; y <= 2} or 
{-x <= -1; x <= 1; -y <= -1; y <= 1} or 
{-x <= -1; x <= 1; -y <= 0; y <= 0}
WIDENING(OP1,OP2)={-x < -3; -y <= -3} or 
{-x < -3; -y <= -2; y <= 2} or 
{-x <= -2; x <= 3; -y <= -3} or 
{-x <= -2; x <= 3; -y <= -2; y <= 2} or 
{-x <= -2; x <= 3; y <= 1} or 
{-x < -1; x < 2; -y <= -2; y <= 2} or 
{-x < -1; x < 2; -y <= -1; y <= 1} or 
{-x <= -1; x <= 1; -y <= -2} or 
{-x <= -1; x <= 1; -y <= -1; y <= 1} or 
{-x <= -1; x <= 1; -y <= 0; y <= 0}
[A] CONVEX(WIDENING(OP1,OP2))={-x <= -1}
--------------------------------
CONVEX(OP1)={x -> [1, +oo]; y -> [0, 2]}
CONVEX(OP2)={x -> [1, +oo]; y -> [0, 3]}
[B] WIDENING(CONVEX(OP1),CONVEX(OP2))={x -> [1, +oo]; y -> [0, +oo]}
--------------------------------
[A] and [B] should be the same if CONVEX distributes over WIDENING 
CFG
x0:
  k = 2147483648;
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Reversed CFG
ret:
--> [bb1_f;]
bb1_f:
  assume(-i <= -100);
--> [bb1;]
bb1:
--> [entry;bb2;]
entry:
  i = 0;
--> [x3;]
x3:
--> [x2;]
x2:
--> [x1;]
x1:
--> [x0;]
x0:
  k = 2147483648;
--> []
bb2:
  i = i+inc;
  inc = ite(-nd <= -1,1,2);
  havoc(nd);
--> [bb1_t;]
bb1_t:
  assume(i <= 99);
--> [bb1;]

Weak reversed topological order of CFG 
ret -- bb1_f -- bb2 -- bb1_t -- bb1 -- entry -- x3 -- x2 -- x1 -- x0
Weak topological order of the reversed CFG 
ret -- bb1_f -- bb1 -- bb2 -- bb1_t -- entry -- x3 -- x2 -- x1 -- x0
Bourdoncle WTO of the reversed CFG
ret bb1_f (bb1 bb2 bb1_t) entry x3 x2 x1 x0
Simplified CFG
x0:
  k = 2147483648;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Reversed simplified CFG
ret:
--> [bb1_f;]
bb1_f:
  assume(-i <= -100);
--> [bb1;]
bb1:
--> [x0;bb1_t;]
x0:
  i = 0;
  k = 2147483648;
--> []
bb1_t:
  i = i+inc;
  inc = ite(-nd <= -1,1,2);
  havoc(nd);
  assume(i <= 99);
--> [bb1;]

CFG
entry:
  goto x1;
x1:
  goto x2,x6,exit;
x2:
  goto x3,x4;
x3:
  goto x5;
x5:
  goto x1;
x4:
  goto x5;
x6:
  goto x7,x8;
x7:
  goto x9;
x9:
  goto exit;
exit:

x8:
  goto x9;

Control-dependence graph 
{x2;x5;x6;x9;}  control-dependent on x1
{x3;x4;}  control-dependent on x2
{x7;x8;}  control-dependent on x6
z:int declare foo(x:int)
entry:
  y = x+1;
  goto exit;
exit:
  z = y+2;
  w = call barz(z:int);
  return w;


y:int declare bar(a:int)
entry:
  x = a;
  goto exit;
exit:
  y = call foo(x:int);
  return y;


void declare main()
entry:
  x = 3;
  y = call bar(x:int);
  goto exit;
exit:
  z = y+2;


bar--> foo
main--> bar

number of predecessors foo=1
bar-->foo
number of successors bar=1
bar-->foo
number of predecessors bar=1
main-->bar
number of successors main=1
main-->bar
Found root main
Printing in preorder ...
main
bar
foo
reverse topological sort: foo--bar--main--
topological sort: main--bar--foo--
Callgraph=
foo--> barz
bar--> foo
main--> bar
barz--> bar

Weak topological ordering=main (bar foo barz)
b0:
  p = &(1);
  q1 = &(2);
  q2 = &(3);
  havoc(nd);
  goto b1,b2;
b1:
  assume(-nd <= -1);
  *(p) = q1;
  goto b3;
b3:
  r = *(p);

b2:
  assume(nd <= 0);
  *(p) = q2;
  goto b3;

Analysis using Product(SplitDBM,Nullity)
b0=({}, {}) ==> ({}, {p -> NN; q1 -> NN; q2 -> NN})
b2=({}, {p -> NN; q1 -> NN; q2 -> NN}) ==> ({nd -> [-oo, 0]}, {p -> NN; q1 -> NN; q2 -> NN})
b3=({}, {p -> NN; q1 -> NN; q2 -> NN}) ==> ({}, {p -> NN; q1 -> NN; q2 -> NN})
b1=({}, {p -> NN; q1 -> NN; q2 -> NN}) ==> ({nd -> [1, +oo]}, {p -> NN; q1 -> NN; q2 -> NN})
Analysis using SplitDBM
b0={} ==> {}
b2={} ==> {nd -> [-oo, 0]}
b3={} ==> {}
b1={} ==> {nd -> [1, +oo]}
 --- SAFE --------------------
Property : p != 0
Invariant: ({}, {p -> NN; q1 -> NN; q2 -> NN})
 -----------------------------
 --- SAFE --------------------
Property : p != 0
Invariant: ({nd -> [-oo, 0]}, {p -> NN; q1 -> NN; q2 -> NN})
 -----------------------------
 --- SAFE --------------------
Property : p != 0
Invariant: ({nd -> [1, +oo]}, {p -> NN; q1 -> NN; q2 -> NN})
 -----------------------------
null-dereference checker
3  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
integer division by zero checker
0  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
user-defined assertion checker using SplitDBM
0  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

Assertion Crawler Analysis 
entry={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
bb1={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
bb1_f={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
ret={}
bb1_t={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}
bb2={"assert(-x <= -200)" -> {x; y}; "assert(-x+y <= 0)" -> {x; y}; "assert(-i <= -200)" -> {i}; "assert(i = 100)" -> {i}}


******* UNJUSTIFIED ASSUMPTION ANALYSIS ********
assert(-i <= -200) with unjustified assumptions:
	assume NotOverflow({x; y}) as a3 in x = x+y
	assume NotOverflow({y}) as a4 in y = y+1
	assume NotOverflow({i}) as a5 in i = i+1
assert(-x <= -200) with unjustified assumptions:
	assume NotOverflow({x; y}) as a9 in x = x+y
	assume NotOverflow({y}) as a10 in y = y+1
	assume NotOverflow({i}) as a11 in i = i+1
assert(-x+y <= 0) with unjustified assumptions:
	assume NotOverflow({x; y}) as a6 in x = x+y
	assume NotOverflow({y}) as a7 in y = y+1
	assume NotOverflow({i}) as a8 in i = i+1
assert(i = 100) with unjustified assumptions:
	assume NotOverflow({x; y}) as a0 in x = x+y
	assume NotOverflow({y}) as a1 in y = y+1
	assume NotOverflow({i}) as a2 in i = i+1
******************* STATS **********************
BRUNCH_STAT Assertions 4
BRUNCH_STAT Assumptions 12
BRUNCH_STAT MaxAssumptionsPerAssertion 3
BRUNCH_STAT AvgAssumptionsPerAssertion 3



******* UNJUSTIFIED ASSUMPTION ANALYSIS ********
assert(-i <= -200) with unjustified assumptions:
	assume NotOverflow({i}) as a2 in i = i+1
assert(-x <= -200) with unjustified assumptions:
	assume NotOverflow({x; y}) as a0 in x = x+y
	assume NotOverflow({y}) as a1 in y = y+1
assert(-x+y <= 0) with unjustified assumptions:
	assume NotOverflow({x; y}) as a0 in x = x+y
	assume NotOverflow({y}) as a1 in y = y+1
assert(i = 100) with unjustified assumptions:
	assume NotOverflow({i}) as a2 in i = i+1
******************* STATS **********************
BRUNCH_STAT Assertions 4
BRUNCH_STAT Assumptions 6
BRUNCH_STAT MaxAssumptionsPerAssertion 2
BRUNCH_STAT AvgAssumptionsPerAssertion 1.5


entry:
  i = 0;
  x = 1;
  y = 0;
  p = NULL;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  q = &(1);
  p = &(q) + 4;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  assume(x-y <= 0);
  assert(i = 100);
  assert(-i <= -200);
  assert(-x+y <= 0);
  assert(-x <= -200);


Analysis using Product(SplitDBM,Nullity)
entry=({}, {}) ==> ({i -> [0, 0], x -> [1, 1], y -> [0, 0]}, {p -> N})
bb1=({i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {}) ==> ({i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {})
bb1_f=({i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {}) ==> ({i -> [100, 100], x -> [100, +oo], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {})
ret=({i -> [100, 100], x -> [100, +oo], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {}) ==> _|_
bb1_t=({i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {}) ==> ({i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {})
bb2=({i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0}, {}) ==> ({y -> [1, 100], i -> [1, 100], x -> [1, +oo], i-y<=0, y-i<=0, y-x<=0, i-x<=0}, {p -> NN; q -> NN})
Analysis using SplitDBM
entry={} ==> {i -> [0, 0], x -> [1, 1], y -> [0, 0]}
bb1={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb1_f={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {i -> [100, 100], x -> [100, +oo], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
ret={i -> [100, 100], x -> [100, +oo], y -> [100, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> _|_
bb1_t={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb2={i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0} ==> {y -> [1, 100], i -> [1, 100], x -> [1, +oo], i-y<=0, y-i<=0, y-x<=0, i-x<=0}
null-dereference checker
0  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
 --- SAFE --------------------
Property : i = 100
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, x-i<=0, y-x<=0, i-x<=0, i-y<=0, x-y<=0}
 -----------------------------
 --- WARNING -----------------
Property : -i <= -200
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, x-i<=0, y-x<=0, i-x<=0, i-y<=0, x-y<=0}
 -----------------------------
integer division by zero checker
0  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
user-defined assertion checker using SplitDBM
1  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
2  Number of total unreachable checks
CFG
x0:
  k = 2147483648;
  o = 4;
  p = &(1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  q = &(p) + o;
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


After Dead Code Elimination
x0:
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Cloned CFG
x0:
  k = 2147483648;
  o = 4;
  p = &(1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  q = &(p) + o;
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


CFG
x0:
  k = 2147483648;
  o = 4;
  p = &(1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  q = &(p) + o;
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  k = *(q);
  return k;


After Dead Code Elimination
x0:
  o = 4;
  p = &(1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  q = &(p) + o;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  k = *(q);
  return k;


Cloned CFG
x0:
  k = 2147483648;
  o = 4;
  p = &(1);
  goto x1;
x1:
  goto x2;
x2:
  goto x3;
x3:
  goto entry;
entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd);
  q = &(p) + o;
  k = 5;
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  k = *(q);
  return k;


entry:
  k = 0;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  i = i+1;
  k = k+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using DisjunctiveIntervals
entry={}
bb1={i -> [0, 100]; k -> [0, +oo]}
bb1_f={i -> [0, 100]; k -> [0, +oo]}
ret={i -> [100, 100]; k -> [0, +oo]}
bb1_t={i -> [0, 100]; k -> [0, +oo]}
bb2={i -> [0, 99]; k -> [0, +oo]}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f ret

entry:
  k = 0;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  i = i+1;
  k = k+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using ElinaOctagon
entry={}
bb1={-i <= 0; i <= 100; i-k <= 0; -i-k <= 0; -k <= 0; i+k <= 200; -i+k <= 0; k <= 100}
bb1_f={-i <= 0; i <= 100; i-k <= 0; -i-k <= 0; -k <= 0; i+k <= 200; -i+k <= 0; k <= 100}
ret={-i <= -100; i <= 100; i-k <= 0; -i-k <= -200; -k <= -100; i+k <= 200; -i+k <= 0; k <= 100}
bb1_t={-i <= 0; i <= 100; i-k <= 0; -i-k <= 0; -k <= 0; i+k <= 200; -i+k <= 0; k <= 100}
bb2={-i <= 0; i <= 99; i-k <= 0; -i-k <= 0; -k <= 0; i+k <= 198; -i+k <= 0; k <= 99}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ElinaPolyhedra
entry={}
bb1={i-k = 0; -i <= 0; i <= 100}
bb1_f={i-k = 0; -i <= 0; i <= 100}
ret={i = 100; -k = -100}
bb1_t={i-k = 0; -i <= 0; i <= 100}
bb2={i-k = 0; -k <= 0; k <= 99}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

loop1_entry:
  i = 0;
  k = 30;
  goto loop1_bb1;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(i <= 9);
  goto loop1_bb2;
loop1_bb2:
  i = i+1;
  goto loop1_bb1;
loop1_bb1_f:
  assume(-i <= -10);
  goto loop2_entry;
loop2_entry:
  j = 0;
  goto loop2_bb1;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(j <= 9);
  goto loop2_bb2;
loop2_bb2:
  j = j+1;
  goto loop2_bb1;
loop2_bb1_f:
  assume(-j <= -10);
  goto ret;
ret:


Invariants using ElinaZones
loop1_entry={}
loop1_bb1={-k <= -30; k <= 30; -i <= 0; i <= 10}
loop1_bb1_f={-k <= -30; k <= 30; -i <= 0; i <= 10}
loop2_entry={-k <= -30; k <= 30; -i <= -10; i <= 10}
loop2_bb1={-k <= -30; k <= 30; -j <= 0; j <= 10; -i <= -10; i <= 10}
loop2_bb1_f={-k <= -30; k <= 30; -j <= 0; j <= 10; -i <= -10; i <= 10}
ret={-k <= -30; k <= 30; -i <= -10; i <= 10; -j <= -10; j <= 10}
loop2_bb1_t={-k <= -30; k <= 30; -j <= 0; j <= 10; -i <= -10; i <= 10}
loop2_bb2={-k <= -30; k <= 30; -i <= -10; i <= 10; -j <= 0; j <= 9}
loop1_bb1_t={-k <= -30; k <= 30; -i <= 0; i <= 10}
loop1_bb2={-k <= -30; k <= 30; -i <= 0; i <= 9}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

Invariants using ElinaOctagon
loop1_entry={}
loop1_bb1={-i <= 0; i <= 10; i-k <= -20; -i-k <= -30; -k <= -30; i+k <= 40; -i+k <= 30; k <= 30}
loop1_bb1_f={-i <= 0; i <= 10; i-k <= -20; -i-k <= -30; -k <= -30; i+k <= 40; -i+k <= 30; k <= 30}
loop2_entry={-i <= -10; i <= 10; i-k <= -20; -i-k <= -40; -k <= -30; i+k <= 40; -i+k <= 20; k <= 30}
loop2_bb1={-i <= -10; i <= 10; i-j <= 10; -i-j <= -10; -j <= 0; i+j <= 20; -i+j <= 0; j <= 10; i-k <= -20; -i-k <= -40; j-k <= -20; -j-k <= -30; -k <= -30; i+k <= 40; -i+k <= 20; j+k <= 40; -j+k <= 30; k <= 30}
loop2_bb1_f={-i <= -10; i <= 10; i-j <= 10; -i-j <= -10; -j <= 0; i+j <= 20; -i+j <= 0; j <= 10; i-k <= -20; -i-k <= -40; j-k <= -20; -j-k <= -30; -k <= -30; i+k <= 40; -i+k <= 20; j+k <= 40; -j+k <= 30; k <= 30}
ret={-i <= -10; i <= 10; i-j <= 0; -i-j <= -20; -j <= -10; i+j <= 20; -i+j <= 0; j <= 10; i-k <= -20; -i-k <= -40; j-k <= -20; -j-k <= -40; -k <= -30; i+k <= 40; -i+k <= 20; j+k <= 40; -j+k <= 20; k <= 30}
loop2_bb1_t={-i <= -10; i <= 10; i-j <= 10; -i-j <= -10; -j <= 0; i+j <= 20; -i+j <= 0; j <= 10; i-k <= -20; -i-k <= -40; j-k <= -20; -j-k <= -30; -k <= -30; i+k <= 40; -i+k <= 20; j+k <= 40; -j+k <= 30; k <= 30}
loop2_bb2={-i <= -10; i <= 10; i-j <= 10; -i-j <= -10; -j <= 0; i+j <= 19; -i+j <= -1; j <= 9; i-k <= -20; -i-k <= -40; j-k <= -21; -j-k <= -30; -k <= -30; i+k <= 40; -i+k <= 20; j+k <= 39; -j+k <= 30; k <= 30}
loop1_bb1_t={-i <= 0; i <= 10; i-k <= -20; -i-k <= -30; -k <= -30; i+k <= 40; -i+k <= 30; k <= 30}
loop1_bb2={-i <= 0; i <= 9; i-k <= -21; -i-k <= -30; -k <= -30; i+k <= 39; -i+k <= 30; k <= 30}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

Invariants using ElinaPolyhedra
loop1_entry={}
loop1_bb1={-i <= 0; i <= 10; -k = -30}
loop1_bb1_f={-i <= 0; i <= 10; -k = -30}
loop2_entry={-i = -10; -k = -30}
loop2_bb1={-j <= 0; j <= 10; -i = -10; -k = -30}
loop2_bb1_f={-j <= 0; j <= 10; -i = -10; -k = -30}
ret={-i = -10; -j = -10; -k = -30}
loop2_bb1_t={-j <= 0; j <= 10; -i = -10; -k = -30}
loop2_bb2={-i = -10; -j <= 0; j <= 9; -k = -30}
loop1_bb1_t={-i <= 0; i <= 10; -k = -30}
loop1_bb2={-i <= 0; i <= 9; -k = -30}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

entry:
  i = 0;
  goto loop1_head;
loop1_head:
  goto loop1_t,loop1_f;
loop1_t:
  assume(i <= 10);
  goto loop1_body;
loop1_body:
  i = i+1;
  goto loop1_body_t,loop1_body_f;
loop1_body_t:
  assume(-i <= -9);
  i = 0;
  goto loop1_body_x;
loop1_body_x:
  goto loop1_head;
loop1_body_f:
  assume(i <= 8);
  goto loop1_body_x;
loop1_f:
  assume(-i <= -11);
  goto cont;
cont:
  goto loop2_head;
loop2_head:
  goto loop2_t,loop2_f;
loop2_t:
  assume(i <= 100);
  goto loop2_body;
loop2_body:
  i = i-1;
  goto loop2_head;
loop2_f:
  assume(-i <= -101);
  goto ret;
ret:


Invariants using ElinaZones
entry={}
loop1_head={-i <= 0; i <= 8}
loop1_f={-i <= 0; i <= 8}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={-i <= 0; i <= 8}
loop1_body={-i <= 0; i <= 8}
loop1_body_f={-i <= -1; i <= 9}
loop1_body_x={-i <= 0; i <= 8}
loop1_body_t={-i <= -1; i <= 9}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using ElinaOctagon
entry={}
loop1_head={-i <= 0; i <= 8}
loop1_f={-i <= 0; i <= 8}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={-i <= 0; i <= 8}
loop1_body={-i <= 0; i <= 8}
loop1_body_f={-i <= -1; i <= 9}
loop1_body_x={-i <= 0; i <= 8}
loop1_body_t={-i <= -1; i <= 9}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using ElinaPolyhedra
entry={}
loop1_head={-i <= 0; i <= 8}
loop1_f={-i <= 0; i <= 8}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={-i <= 0; i <= 8}
loop1_body={-i <= 0; i <= 8}
loop1_body_f={i <= 9; -i <= -1}
loop1_body_x={-i <= 0; i <= 8}
loop1_body_t={i <= 9; -i <= -1}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

entry:
  i = 0;
  p = 0;
  goto loop_head;
loop_head:
  goto loop_t,loop_f;
loop_t:
  assume(i <= 9);
  goto loop_body;
loop_body:
  i = i+1;
  p = p+4;
  goto loop_head;
loop_f:
  assume(-i <= -10);
  goto ret;
ret:


Invariants using ElinaZones
entry={}
loop_head={-i <= 0; i <= 10; i-p <= 0; -p <= 0}
loop_f={-i <= 0; i <= 10; i-p <= 0; -p <= 0}
ret={-i <= -10; i <= 10; i-p <= 0; -p <= -10}
loop_t={-i <= 0; i <= 10; i-p <= 0; -p <= 0}
loop_body={-i <= 0; i <= 9; i-p <= 0; -p <= 0}
Abstract trace: entry (loop_head loop_t loop_body)^{3} loop_f ret

Invariants using ElinaOctagon
entry={}
loop_head={-i <= 0; i <= 10; i-p <= 0; -i-p <= 0; -p <= 0}
loop_f={-i <= 0; i <= 10; i-p <= 0; -i-p <= 0; -p <= 0}
ret={-i <= -10; i <= 10; i-p <= 0; -i-p <= -20; -p <= -10}
loop_t={-i <= 0; i <= 10; i-p <= 0; -i-p <= 0; -p <= 0}
loop_body={-i <= 0; i <= 9; i-p <= 0; -i-p <= 0; -p <= 0}
Abstract trace: entry (loop_head loop_t loop_body)^{3} loop_f ret

Invariants using ElinaPolyhedra
entry={}
loop_head={4*i-p = 0; -i <= 0; i <= 10}
loop_f={4*i-p = 0; -i <= 0; i <= 10}
ret={i = 10; -p = -40}
loop_t={4*i-p = 0; -i <= 0; i <= 10}
loop_body={4*i-p = 0; -p <= 0; p <= 36}
Abstract trace: entry (loop_head loop_t loop_body)^{3} loop_f ret

entry:
  k = 0;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i != 9);
  goto bb2;
bb2:
  i = i+1;
  k = k+1;
  goto bb1;
bb1_f:
  assume(i = 9);
  goto ret;
ret:


Invariants using ElinaZones
entry={}
bb1={k <= 0; -i <= 0; -k <= 0}
bb1_f={k <= 0; -i <= 0; -k <= 0}
ret={k <= 0; -i <= -9; i <= 9; i-k <= 9; -k <= 0; k <= 9}
bb1_t={k <= 0; -i <= 0; -k <= 0}
bb2={k <= 0; -i <= 0; -k <= 0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ElinaOctagon
entry={}
bb1={-i <= 0; i-k <= 0; -i-k <= 0; -k <= 0; -i+k <= 0}
bb1_f={-i <= 0; i-k <= 0; -i-k <= 0; -k <= 0; -i+k <= 0}
ret={-i <= -9; i <= 9; i-k <= 0; -i-k <= -18; -k <= -9; i+k <= 18; -i+k <= 0; k <= 9}
bb1_t={-i <= 0; i-k <= 0; -i-k <= 0; -k <= 0; -i+k <= 0}
bb2={-i <= 0; i-k <= 0; -i-k <= 0; -k <= 0; -i+k <= 0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using ElinaPolyhedra
entry={}
bb1={i-k = 0; -i <= 0}
bb1_f={i-k = 0; -i <= 0}
ret={i = 9; -k = -9}
bb1_t={i-k = 0; -i <= 0}
bb2={i-k = 0; -k <= 0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

{x -> [5, 10]} does not entail x = 7
{x -> [5, 10]} does not entail x = 11
{x -> [5, 5], y -> [0, 10]} entails x = 5
{x -> [5, 5], y -> [0, 10]} does not entail x = 7
{x -> [5, 5], y -> [0, 10]} entails y != 42
z:int declare foo(x:int)
entry:
  y = x+1;
  goto exit;
exit:
  z = y+2;
  return z;


y1:int declare bar(a:int)
entry:
  x1 = a;
  w1 = 5;
  goto exit;
exit:
  y1 = call foo(x1:int);
  return y1;


t:int declare rec1(s:int)
entry:
  r = s-1;
  goto exit;
exit:
  t = call rec2(r:int);
  return t;


t1:int declare rec2(s1:int)
entry:
  r1 = s1-1;
  goto exit;
exit:
  t1 = call rec1(r1:int);
  return t1;


w2:int declare main()
entry:
  x2 = 3;
  y2 = call bar(x2:int);
  z3 = call rec1(y2:int);
  goto exit;
exit:
  z2 = y2+2;
  w2 = call foo(z2:int);
  return w2;


Running summary domain=SparseDBM and forward domain=Intervals
z:int declare foo(x:int)
exit={x -> [3, 8]; y -> [4, 9]; z -> [6, 11]}
entry={x -> [3, 8]; y -> [4, 9]}
=================================
y1:int declare bar(a:int)
exit={a -> [3, 3]; x1 -> [3, 3]; y1 -> [6, 6]; w1 -> [5, 5]}
entry={a -> [3, 3]; x1 -> [3, 3]; w1 -> [5, 5]}
=================================
t:int declare rec1(s:int)
exit={}
entry={}
=================================
t1:int declare rec2(s1:int)
exit={}
entry={}
=================================
w2:int declare main()
exit={x2 -> [3, 3]; y2 -> [6, 6]; z2 -> [8, 8]; w2 -> [11, 11]}
entry={x2 -> [3, 3]; y2 -> [6, 6]}
=================================
Summary foo(IN:{x:int},OUT:{z:int}) ==>
{z-x<=3, x-z<=-3}
Summary bar(IN:{a:int},OUT:{y1:int}) ==>
{y1-a<=3, a-y1<=-3}
Summary rec1(IN:{s:int},OUT:{t:int}) ==>
{}
Summary rec2(IN:{s1:int},OUT:{t1:int}) ==>
{}
x0:
  k = 2147483648;
  i = crab_intrinsic(foo1,i:int,k:int);
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  i = crab_intrinsic(foo2,i:int,k:int);
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


{}
{}
({}, {})
({}, {})
({}, {})
{}
Join 
Widening 
Widening of 
{-x <= 0; x <= 1/4; -y <= -1/4; y <= 1/2}and
{-x <= -1/4; x <= 1; -y <= -1/8; y <= 1/4} or 
{-x <= 0; x <= 0; -y <= -1/2; y <= 1/2} = 
{-x < -1/4; -y <= -1/8; y <= 1/4} or 
{-x <= 0; x <= 1/4; y <= 1/2}
Analysis using SplitDBM
 --- SAFE --------------------
Property : i = 100
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, x-i<=0, y-x<=0, i-x<=0, i-y<=0, x-y<=0}
 -----------------------------
 --- WARNING -----------------
Property : -i <= -200
Invariant: {i -> [100, 100], x -> [100, 100], y -> [100, 100], y-i<=0, x-i<=0, y-x<=0, i-x<=0, i-y<=0, x-y<=0}
 -----------------------------
user-defined assertion checker using SplitDBM
1  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
2  Number of total unreachable checks
Before replacing safe assertions with assume statements
entry:
  i = 0;
  x = 1;
  y = 0;
  p = NULL;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  q = &(1);
  p = &(q) + 4;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  assume(x-y <= 0);
  assert(i = 100);
  assert(-i <= -200);
  assert(-x+y <= 0);
  assert(-x <= -200);


After replacing safe assertions with assume statements
entry:
  i = 0;
  x = 1;
  y = 0;
  p = NULL;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  q = &(1);
  p = &(q) + 4;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  assume(x-y <= 0);
  assume(i = 100);
  assert(-i <= -200);
  assert(-x+y <= 0);
  assert(-x <= -200);


entry:
  i = 0;
  goto l1;
l1:
  i = i+1;
  j = 0;
  goto l2;
l2:
  goto l2_body,l2_exit;
l2_body:
  assume(j <= 9);
  assert(-i <= 0);
  assert(i <= 10);
  j = j+1;
  goto l2;
l2_exit:
  assume(-j <= -10);
  goto l1_reset,l1_dont_reset;
l1_reset:
  assume(-i <= -10);
  i = 0;
  goto l1;
l1_dont_reset:
  assume(i <= 9);
  goto l1;

Invariants using Intervals
entry={}
l1={i -> [0, 9]}
l2={i -> [1, 10]; j -> [0, 10]}
l2_exit={i -> [1, 10]; j -> [0, 10]}
l1_dont_reset={i -> [1, 10]; j -> [10, 10]}
l1_reset={i -> [1, 10]; j -> [10, 10]}
l2_body={i -> [1, 10]; j -> [0, 10]}
Abstract trace: entry (l1 (l2 l2_body)^{12} l2_exit l1_dont_reset l1_reset)^{3}
 --- SAFE --------------------
Property : -i <= 0
Invariant: {i -> [1, 10]; j -> [0, 9]}
 -----------------------------
 --- SAFE --------------------
Property : i <= 10
Invariant: {i -> [1, 10]; j -> [0, 9]}
 -----------------------------
user-defined assertion checker using Intervals
2  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  i = 0;
  goto l1;
l1:
  assume(i <= 3);
  j = 0;
  goto l2;
l2:
  goto l2_body,l2_exit;
l2_body:
  assume(j <= 3);
  assert(i-j <= 3);
  i = i+1;
  j = j+1;
  goto l2;
l2_exit:
  assume(-j <= -4);
  i = i-j+1;
  goto l1;

Invariants using Intervals
entry={}
l1={i -> [-oo, 4]}
l2={i -> [-oo, 7]; j -> [0, 4]}
l2_exit={i -> [-oo, 7]; j -> [0, 4]}
l2_body={i -> [-oo, 7]; j -> [0, 4]}
Abstract trace: entry (l1 (l2 l2_body)^{13} l2_exit)^{3}
 --- WARNING -----------------
Property : i-j <= 3
Invariant: {i -> [-oo, 7]; j -> [0, 3]}
 -----------------------------
user-defined assertion checker using Intervals
0  Number of total safe checks
0  Number of total error checks
1  Number of total warning checks
0  Number of total unreachable checks

Invariants using SplitDBM
entry={}
l1={i -> [0, 4]}
l2={i -> [0, 7], j -> [0, 4], j-i<=0, i-j<=3}
l2_exit={i -> [0, 7], j -> [0, 4], j-i<=0, i-j<=3}
l2_body={i -> [0, 7], j -> [0, 4], j-i<=0, i-j<=3}
Abstract trace: entry (l1 (l2 l2_body)^{12} l2_exit)^{3}
 --- SAFE --------------------
Property : i-j <= 3
Invariant: {i -> [0, 6], j -> [0, 3], j-i<=0, i-j<=3}
 -----------------------------
user-defined assertion checker using SplitDBM
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

entry:
  i = 0;
  goto l1;
l1:
  assert(-i <= 0);
  j = 0;
  goto l2;
l2:
  goto l2_body,l2_exit;
l2_body:
  assume(j <= 9);
  j = j+1;
  goto l2;
l2_exit:
  assume(-j <= -10);
  i = i-j+11;
  goto l1;

Invariants using Intervals
entry={}
l1={i -> [0, +oo]}
l2={i -> [0, +oo]; j -> [0, 10]}
l2_exit={i -> [0, +oo]; j -> [0, 10]}
l2_body={i -> [0, +oo]; j -> [0, 10]}
Abstract trace: entry (l1 (l2 l2_body)^{15} l2_exit)^{4}
 --- SAFE --------------------
Property : -i <= 0
Invariant: {i -> [0, +oo]}
 -----------------------------
user-defined assertion checker using Intervals
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

b0:
  p = &(1);
  havoc(r);
  havoc(s);
  goto b1,b2;
b1:
  assume_ptr(r == NULL);
  assume_ptr(r == s);
  goto b3;
b3:

b2:
  assume_ptr(r != s);
  q = &(2);
  p = &(q) + 4;
  goto b3;

Invariants using Nullity
b0={}
b2={p -> NN}
b3={p -> NN}
b1={p -> NN}
Abstract trace: b0 b2 b1 b3

b0:
  p = &(1);
  q1 = &(2);
  q2 = &(3);
  havoc(nd);
  goto b1,b2;
b1:
  assume(-nd <= -1);
  *(p) = q1;
  goto b3;
b3:
  r = *(p);

b2:
  assume(nd <= 0);
  *(p) = q2;
  goto b3;

Invariants using Nullity
b0={}
b2={p -> NN; q1 -> NN; q2 -> NN}
b3={p -> NN; q1 -> NN; q2 -> NN}
b1={p -> NN; q1 -> NN; q2 -> NN}
Abstract trace: b0 b2 b1 b3

entry:
  i = 0;
  x = 1;
  y = 0;
  p = NULL;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  x = x+y;
  y = y+1;
  q = &(1);
  p = &(q) + 4;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:
  assume(x-y <= 0);


Invariants using Nullity
entry={}
bb1={}
bb1_f={}
ret={}
bb1_t={}
bb2={}
Abstract trace: entry (bb1 bb1_t bb2)^{2} bb1_f ret

entry:
  x = 0;
  y = 1;
  goto b1;
b1:
  goto b1_tt,b1_ff;
b1_tt:
  assume(-nd1 <= -1);
  x = x+1;
  y = y+2;
  goto b2;
b2:
  goto b2_tt,b2_ff;
b2_tt:
  assume(-nd2 <= -1);
  x = x+2;
  y = y+3;
  goto b3;
b3:
  goto b3_tt,b3_ff;
b3_tt:
  assume(-nd3 <= -1);
  y = y+1;
  goto exit;
exit:
  assert(x-y <= -1);

b3_ff:
  assume(nd3 <= 0);
  goto exit;
b2_ff:
  assume(nd2 <= 0);
  goto b3;
b1_ff:
  assume(nd1 <= 0);
  goto b2;

Invariants using Powerset(ArrayAdaptive(ArraySmashing(Intervals)))
entry=top
b1={x -> [0, 0]; y -> [1, 1]}
b1_ff={x -> [0, 0]; y -> [1, 1]}
b2={x -> [1, 1]; y -> [3, 3]; nd1 -> [1, +oo]} or 
{x -> [0, 0]; y -> [1, 1]; nd1 -> [-oo, 0]}
b2_ff={x -> [1, 1]; y -> [3, 3]; nd1 -> [1, +oo]} or 
{x -> [0, 0]; y -> [1, 1]; nd1 -> [-oo, 0]}
b3={x -> [3, 3]; y -> [6, 6]; nd1 -> [1, +oo]; nd2 -> [1, +oo]} or 
{x -> [2, 2]; y -> [4, 4]; nd1 -> [-oo, 0]; nd2 -> [1, +oo]} or 
{x -> [1, 1]; y -> [3, 3]; nd1 -> [1, +oo]; nd2 -> [-oo, 0]} or 
{x -> [0, 0]; y -> [1, 1]; nd1 -> [-oo, 0]; nd2 -> [-oo, 0]}
b3_ff={x -> [3, 3]; y -> [6, 6]; nd1 -> [1, +oo]; nd2 -> [1, +oo]} or 
{x -> [2, 2]; y -> [4, 4]; nd1 -> [-oo, 0]; nd2 -> [1, +oo]} or 
{x -> [1, 1]; y -> [3, 3]; nd1 -> [1, +oo]; nd2 -> [-oo, 0]} or 
{x -> [0, 0]; y -> [1, 1]; nd1 -> [-oo, 0]; nd2 -> [-oo, 0]}
exit={x -> [3, 3]; y -> [7, 7]; nd1 -> [1, +oo]; nd2 -> [1, +oo]; nd3 -> [1, +oo]} or 
{x -> [2, 2]; y -> [5, 5]; nd1 -> [-oo, 0]; nd2 -> [1, +oo]; nd3 -> [1, +oo]} or 
{x -> [1, 1]; y -> [4, 4]; nd1 -> [1, +oo]; nd2 -> [-oo, 0]; nd3 -> [1, +oo]} or 
{x -> [0, 0]; y -> [2, 2]; nd1 -> [-oo, 0]; nd2 -> [-oo, 0]; nd3 -> [1, +oo]} or 
{x -> [3, 3]; y -> [6, 6]; nd1 -> [1, +oo]; nd2 -> [1, +oo]; nd3 -> [-oo, 0]} or 
{x -> [2, 2]; y -> [4, 4]; nd1 -> [-oo, 0]; nd2 -> [1, +oo]; nd3 -> [-oo, 0]} or 
{x -> [1, 1]; y -> [3, 3]; nd1 -> [1, +oo]; nd2 -> [-oo, 0]; nd3 -> [-oo, 0]} or 
{x -> [0, 0]; y -> [1, 1]; nd1 -> [-oo, 0]; nd2 -> [-oo, 0]; nd3 -> [-oo, 0]}
b3_tt={x -> [3, 3]; y -> [6, 6]; nd1 -> [1, +oo]; nd2 -> [1, +oo]} or 
{x -> [2, 2]; y -> [4, 4]; nd1 -> [-oo, 0]; nd2 -> [1, +oo]} or 
{x -> [1, 1]; y -> [3, 3]; nd1 -> [1, +oo]; nd2 -> [-oo, 0]} or 
{x -> [0, 0]; y -> [1, 1]; nd1 -> [-oo, 0]; nd2 -> [-oo, 0]}
b2_tt={x -> [1, 1]; y -> [3, 3]; nd1 -> [1, +oo]} or 
{x -> [0, 0]; y -> [1, 1]; nd1 -> [-oo, 0]}
b1_tt={x -> [0, 0]; y -> [1, 1]}
Abstract trace: entry b1 b1_ff b1_tt b2 b2_ff b2_tt b3 b3_ff b3_tt exit
 --- SAFE --------------------
Property : x-y <= -1
Invariant: {x -> [3, 3]; y -> [7, 7]; nd1 -> [1, +oo]; nd2 -> [1, +oo]; nd3 -> [1, +oo]} or 
{x -> [2, 2]; y -> [5, 5]; nd1 -> [-oo, 0]; nd2 -> [1, +oo]; nd3 -> [1, +oo]} or 
{x -> [1, 1]; y -> [4, 4]; nd1 -> [1, +oo]; nd2 -> [-oo, 0]; nd3 -> [1, +oo]} or 
{x -> [0, 0]; y -> [2, 2]; nd1 -> [-oo, 0]; nd2 -> [-oo, 0]; nd3 -> [1, +oo]} or 
{x -> [3, 3]; y -> [6, 6]; nd1 -> [1, +oo]; nd2 -> [1, +oo]; nd3 -> [-oo, 0]} or 
{x -> [2, 2]; y -> [4, 4]; nd1 -> [-oo, 0]; nd2 -> [1, +oo]; nd3 -> [-oo, 0]} or 
{x -> [1, 1]; y -> [3, 3]; nd1 -> [1, +oo]; nd2 -> [-oo, 0]; nd3 -> [-oo, 0]} or 
{x -> [0, 0]; y -> [1, 1]; nd1 -> [-oo, 0]; nd2 -> [-oo, 0]; nd3 -> [-oo, 0]}
 -----------------------------
user-defined assertion checker using Powerset(ArrayAdaptive(ArraySmashing(Intervals)))
1  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks

bb0:
  goto bb1,bb2;
bb1:
  assume(-argc <= -3);
  assert(-len <= -3);
  goto bb3;
bb3:
  goto bb4,bb5;
bb4:
  assume(-argc <= -2);
  assert(-len <= -2);
  goto bb6;
bb6:

bb5:
  goto bb6;
bb2:
  goto bb3;

Necessary preconditions from error states using Polyhedra:
bb0={len <= 2; -argc+len <= -1; -argc <= -2}
bb2={len <= 1; -argc <= -2}
bb3={len <= 1; -argc <= -2}
bb5=_|_
bb6=_|_
bb4={len <= 1; -argc <= -2}
bb1={-argc <= -3; len <= 2}
Necessary preconditions from safe states using Polyhedra:
bb0={}
bb2={}
bb3={}
bb5={}
bb6={}
bb4={-len <= -2; -argc <= -2}
bb1={-len <= -3; -argc <= -3}
bb1:
  i = 0;
  goto bb2;
bb2:
  goto bb3,bb5;
bb3:
  assume(i-n <= 0);
  assert(-i <= 0);
  assert(i-n <= -1);
  i = i+1;
  goto bb4;
bb4:
  goto bb2,bb5;
bb5:
  assume(-i <= -100);


Necessary preconditions from error states using Polyhedra:
bb1={-n <= 0}
bb2={i-n <= 0}
bb5=_|_
bb3={i-n <= 0}
bb4={i-n <= 0}
Necessary preconditions from safe states using Polyhedra:
bb1={}
bb2={-i <= 0}
bb5={-i <= -100}
bb3={i-n <= -1; -i <= 0}
bb4={-i <= 0}
z:int declare foo(x:int)
entry:
  y = x+1;
  goto exit;
exit:
  z = y+2;
  return z;


y1:int declare bar(a:int)
entry:
  x1 = a;
  w1 = 5;
  goto exit;
exit:
  y1 = call foo(x1:int);
  assert(-y1 <= -6);
  assert(y1 <= 17);
  return y1;


t:int declare rec1(s:int)
entry:
  r = s-1;
  goto exit;
exit:
  t = call rec2(r:int);
  return t;


t1:int declare rec2(s1:int)
entry:
  a = 10;
  r1 = s1-1;
  goto exit;
exit:
  t1 = call rec1(r1:int);
  assert(-a <= -5);
  return t1;


w2:int declare main()
entry:
  x2 = 3;
  x3 = 4;
  x4 = 5;
  x5 = 6;
  y2 = call bar(x2:int);
  assert(y2 = 6);
  __ = call rec1(y2:int);
  goto exit;
exit:
  z2 = y2+2;
  y3 = call bar(x2:int);
  assert(y3 = 6);
  z3 = y3+z2;
  w2 = call foo(z3:int);
  assert(w2 = 17);
  y4 = call bar(x3:int);
  assert(y4 = 7);
  y5 = call bar(x4:int);
  assert(y5 = 8);
  y6 = call bar(x5:int);
  assert(y6 = 9);
  res = w2+y4;
  res = res+y5;
  res = res+y6;
  assert(res = 41);
  return res;


Running top-down inter-procedural analysis with SparseDBM
16  Number of total safe checks
 0  Number of total error checks
 0  Number of total warning checks
 0  Number of total unreachable checks
15  Number of total safe checks
 0  Number of total error checks
 1  Number of total warning checks
 0  Number of total unreachable checks
Running top-down inter-procedural analysis with SplitDBM
16  Number of total safe checks
 0  Number of total error checks
 0  Number of total warning checks
 0  Number of total unreachable checks
15  Number of total safe checks
 0  Number of total error checks
 1  Number of total warning checks
 0  Number of total unreachable checks
Running top-down inter-procedural analysis with ElinaOctagon
16  Number of total safe checks
 0  Number of total error checks
 0  Number of total warning checks
 0  Number of total unreachable checks
15  Number of total safe checks
 0  Number of total error checks
 1  Number of total warning checks
 0  Number of total unreachable checks
(x_out:int,y_out:int) declare loop(x_in:int,y_in:int)
entry:
  goto rec_case,base_case;
rec_case:
  assume(x_in <= 100);
  x_next = x_in+1;
  y_next = y_in+1;
  (x_out,y_out)= call loop(x_next:int,y_next:int);
  goto exit;
exit:
  return (x_out,y_out);

base_case:
  assume(-x_in <= -101);
  x_out = x_in;
  y_out = y_in;
  goto exit;

(x_res:int,y_res:int) declare main()
entry:
  x = 0;
  y = 0;
  (x_res,y_res)= call loop(x:int,y:int);
  goto exit;
exit:
  return (x_res,y_res);


(x_out:int,y_out:int) declare loop(x_in:int,y_in:int)
entry={}
base_case={}
exit={}
rec_case={}
=================================
(x_res:int,y_res:int) declare main()
entry={}
exit={x -> [0, 0], y -> [0, 0], y-x<=0, x-y<=0}
=================================
z:int declare foo(x:int,y:int)
entry:
  goto exit;
exit:
  z = x;
  return z;


void declare main()
entry:
  x = 5;
  y = 10;
  z = 8;
  goto exit;
exit:
  z = call foo(x:int,y:int);
  assert(x = 5);
  assert(y = 10);
  assert(z = 5);


Running top-down inter-procedural analysis with SplitDBM
3  Number of total safe checks
0  Number of total error checks
0  Number of total warning checks
0  Number of total unreachable checks
x0:
  k = 50;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Intervals
x0={}
bb1={i -> [0, 100]; k -> [50, 50]}
bb1_f={i -> [0, 100]; k -> [50, 50]}
ret={i -> [100, 100]; k -> [50, 50]}
bb1_t={i -> [0, 100]; k -> [50, 50]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using Term(Intervals)
x0={}
bb1={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [0, 100]}
bb1_f={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [0, 100]}
ret={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [100, 100]}
bb1_t={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [50, 50]; _y1 -> [0, 100]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

p0:
  x = 50;
  havoc(y);
  assume(-y <= 1);
  assume(y <= 1);
  z = x*y;
  goto p_pos,p_neg;
p_pos:
  assume(-y <= 0);
  goto exit;
exit:
  z0 = z;
  y0 = y;
  goto ret;
ret:

p_neg:
  assume(y <= -1);
  z = z*-1;
  goto exit;

Invariants using Intervals
p0={}
p_neg={y -> [-1, 1]; z -> [-50, 50]}
exit={y -> [-1, 1]; z -> [-50, 50]}
ret={y -> [-1, 1]; z -> [-50, 50]; z0 -> [-50, 50]; y0 -> [-1, 1]}
p_pos={y -> [-1, 1]; z -> [-50, 50]}
Abstract trace: p0 p_neg p_pos exit ret

Invariants using Term(Intervals)
p0={}
p_neg={y -> t1[_x1], z -> t2[_x2]}{_x0 -> [50, 50]; _x1 -> [-1, 1]; _x2 -> [-50, 50]}
exit={y -> t0[_y0], z -> t3[_y3]}{_y0 -> [-1, 1]; _y1 -> [-50, 50]; _y2 -> [-1, 1]; _y3 -> [0, 50]}
ret={y -> t0[_y0], z -> t3[_y3], z0 -> t3[_y3], y0 -> t0[_y0]}{_y0 -> [-1, 1]; _y1 -> [-50, 50]; _y2 -> [-1, 1]; _y3 -> [0, 50]}
p_pos={y -> t1[_x1], z -> t2[_x2]}{_x0 -> [50, 50]; _x1 -> [-1, 1]; _x2 -> [-50, 50]}
Abstract trace: p0 p_neg p_pos exit ret

entry:
  i = 0;
  x = 5;
  y = 5;
  z = 3;
  w = 3;
  s = 0;
  t = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  havoc(nd1);
  havoc(nd2);
  x = x&nd1;
  y = y&nd1;
  z = z|nd1;
  w = w|nd1;
  s = nd1^nd2;
  t = nd1^nd2;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Intervals
entry={}
bb1={i -> [0, 100]}
bb1_f={i -> [0, 100]}
ret={i -> [100, 100]}
bb1_t={i -> [0, 100]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

Invariants using SparseDBM
entry={}
bb1={i -> [0, 100]}
bb1_f={i -> [0, 100]}
ret={i -> [100, 100]}
bb1_t={i -> [0, 100]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

Invariants using Term(Intervals)
entry={}
bb1={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [0, 100]}
bb1_f={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [0, 100]}
ret={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [100, 100]}
bb1_t={i -> t0[_y1], x -> t1[_y2], y -> t1[_y2], z -> t2[_y3], w -> t2[_y3], s -> t3[_y0], t -> t3[_y0]}{_y1 -> [0, 100]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

x0:
  k = 2147483648;
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto ret;
ret:


Invariants using Intervals
x0={}
bb1={i -> [0, 101]; k -> [2147483648, 2147483648]}
bb1_f={i -> [0, 101]; k -> [2147483648, 2147483648]}
ret={i -> [100, 101]; k -> [2147483648, 2147483648]}
bb1_t={i -> [0, 101]; k -> [2147483648, 2147483648]}
Abstract trace: x0 (bb1 bb1_t)^{4} bb1_f ret

Invariants using SparseDBM
x0={}
bb1={i -> [0, 101], k -> [2147483648, 2147483648], k-i<=2147483648, i-k<=-2147483547}
bb1_f={i -> [0, 101], k -> [2147483648, 2147483648], k-i<=2147483648, i-k<=-2147483547}
ret={i -> [100, 101], k -> [2147483648, 2147483648], k-i<=2147483548, i-k<=-2147483547}
bb1_t={i -> [0, 101], k -> [2147483648, 2147483648], k-i<=2147483648, i-k<=-2147483547}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using SplitDBM
x0={}
bb1={i -> [0, 101], k -> [2147483648, 2147483648]}
bb1_f={i -> [0, 101], k -> [2147483648, 2147483648]}
ret={i -> [100, 101], k -> [2147483648, 2147483648]}
bb1_t={i -> [0, 101], k -> [2147483648, 2147483648]}
Abstract trace: x0 (bb1 bb1_t)^{3} bb1_f ret

Invariants using Product(Intervals,Congruences)
x0=({}, {})
bb1=({i -> [0, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
bb1_f=({i -> [0, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
ret=({i -> [100, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
bb1_t=({i -> [0, 101]; k -> [2147483648, 2147483648]}, {k -> 2147483648})
Abstract trace: x0 (bb1 bb1_t)^{4} bb1_f ret

Invariants using Term(Intervals)
x0={}
bb1={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [2147483648, 2147483648]; _y1 -> [0, 101]}
bb1_f={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [2147483648, 2147483648]; _y1 -> [0, 101]}
ret={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [2147483648, 2147483648]; _y1 -> [100, 101]}
bb1_t={i -> t0[_y1], k -> t1[_y0]}{_y0 -> [2147483648, 2147483648]; _y1 -> [0, 101]}
Abstract trace: x0 (bb1 bb1_t)^{4} bb1_f ret

Invariants using DisjunctiveIntervals
x0={}
bb1={i -> [0, 101]; k -> [2147483648, 2147483648]}
bb1_f={i -> [0, 101]; k -> [2147483648, 2147483648]}
ret={i -> [100, 101]; k -> [2147483648, 2147483648]}
bb1_t={i -> [0, 101]; k -> [2147483648, 2147483648]}
Abstract trace: x0 (bb1 bb1_t)^{4} bb1_f ret

entry:
  i = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 5573204538870989/562949953421312);
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -10);
  goto ret;
ret:


Invariants using Intervals
entry={}
bb1={i -> [0, 6136154492292301/562949953421312]}
bb1_f={i -> [0, 6136154492292301/562949953421312]}
ret={i -> [10, 6136154492292301/562949953421312]}
bb1_t={i -> [0, 6136154492292301/562949953421312]}
Abstract trace: entry (bb1 bb1_t)^{3} bb1_f ret

loop1_entry:
  i = 0;
  k = 30;
  goto loop1_bb1;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(i <= 9);
  i = i+1;
  goto loop1_bb1;
loop1_bb1_f:
  assume(-i <= -10);
  j = 0;
  goto loop2_bb1;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(j <= 9);
  j = j+1;
  goto loop2_bb1;
loop2_bb1_f:
  assume(-j <= -10);
  goto ret;
ret:


Invariants using Intervals
loop1_entry={}
loop1_bb1={i -> [0, 10]; k -> [30, 30]}
loop1_bb1_f={i -> [0, 10]; k -> [30, 30]}
loop2_bb1={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb1_f={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
ret={i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}
loop2_bb1_t={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop1_bb1_t={i -> [0, 10]; k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using SparseDBM
loop1_entry={}
loop1_bb1={i -> [0, 10], k -> [30, 30], k-i<=30, i-k<=-20}
loop1_bb1_f={i -> [0, 10], k -> [30, 30], k-i<=30, i-k<=-20}
loop2_bb1={i -> [10, 10], j -> [0, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=10, k-j<=30, i-k<=-20, j-k<=-20}
loop2_bb1_f={i -> [10, 10], j -> [0, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=10, k-j<=30, i-k<=-20, j-k<=-20}
ret={i -> [10, 10], j -> [10, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=0, k-j<=20, i-k<=-20, j-k<=-20}
loop2_bb1_t={i -> [10, 10], j -> [0, 10], k -> [30, 30], k-i<=20, j-i<=0, i-j<=10, k-j<=30, i-k<=-20, j-k<=-20}
loop1_bb1_t={i -> [0, 10], k -> [30, 30], k-i<=30, i-k<=-20}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using SplitDBM
loop1_entry={}
loop1_bb1={i -> [0, 10], k -> [30, 30]}
loop1_bb1_f={i -> [0, 10], k -> [30, 30]}
loop2_bb1={i -> [10, 10], j -> [0, 10], k -> [30, 30]}
loop2_bb1_f={i -> [10, 10], j -> [0, 10], k -> [30, 30]}
ret={i -> [10, 10], j -> [10, 10], k -> [30, 30]}
loop2_bb1_t={i -> [10, 10], j -> [0, 10], k -> [30, 30]}
loop1_bb1_t={i -> [0, 10], k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using Product(Intervals,Congruences)
loop1_entry=({}, {})
loop1_bb1=({i -> [0, 10]; k -> [30, 30]}, {k -> 30})
loop1_bb1_f=({i -> [0, 10]; k -> [30, 30]}, {k -> 30})
loop2_bb1=({i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}, {i -> 10; k -> 30})
loop2_bb1_f=({i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}, {i -> 10; k -> 30})
ret=({i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}, {i -> 10; j -> 10; k -> 30})
loop2_bb1_t=({i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}, {i -> 10; k -> 30})
loop1_bb1_t=({i -> [0, 10]; k -> [30, 30]}, {k -> 30})
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using Term(Intervals)
loop1_entry={}
loop1_bb1={i -> t0[_y0], k -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [30, 30]}
loop1_bb1_f={i -> t0[_y0], k -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [30, 30]}
loop2_bb1={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [0, 10]}
loop2_bb1_f={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [0, 10]}
ret={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [10, 10]}
loop2_bb1_t={i -> t0[_x0], j -> t1[_x2], k -> t2[_x1]}{_x0 -> [10, 10]; _x1 -> [30, 30]; _x2 -> [0, 10]}
loop1_bb1_t={i -> t0[_y0], k -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

Invariants using DisjunctiveIntervals
loop1_entry={}
loop1_bb1={i -> [0, 10]; k -> [30, 30]}
loop1_bb1_f={i -> [0, 10]; k -> [30, 30]}
loop2_bb1={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb1_f={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
ret={i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}
loop2_bb1_t={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop1_bb1_t={i -> [0, 10]; k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t)^{3} loop1_bb1_f (loop2_bb1 loop2_bb1_t)^{3} loop2_bb1_f ret

entry:
  x = 0;
  y = 1/2;
  goto bb1;
bb1:
  x = x+y;
  y = y/2;
  goto bb1;

Invariants using Intervals
entry={}
bb1={x -> [0, +oo]; y -> [0, 1/2]}
Abstract trace: entry (bb1)^{3}

Invariants using Boxes
entry={}
bb1={-x < 0; y <= 1/4} or 
{-x <= 0; x <= 0; -y <= -1/2; y <= 1/2} or 
{-x <= 0; x <= 0; y <= 1/4} or 
{x < 0; y <= 1/4}
Abstract trace: entry (bb1)^{4}

entry:
  i = 0;
  goto loop1_head;
loop1_head:
  goto loop1_t,loop1_f;
loop1_t:
  assume(i <= 10);
  goto loop1_body;
loop1_body:
  i = i+1;
  goto loop1_body_t,loop1_body_f;
loop1_body_t:
  assume(-i <= -9);
  i = 0;
  goto loop1_body_x;
loop1_body_x:
  goto loop1_head;
loop1_body_f:
  assume(i <= 8);
  goto loop1_body_x;
loop1_f:
  assume(-i <= -11);
  goto cont;
cont:
  goto loop2_head;
loop2_head:
  goto loop2_t,loop2_f;
loop2_t:
  assume(i <= 100);
  goto loop2_body;
loop2_body:
  i = i-1;
  goto loop2_head;
loop2_f:
  assume(-i <= -101);
  goto ret;
ret:


Invariants using Intervals
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using SparseDBM
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using SplitDBM
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using Product(Intervals,Congruences)
entry=({}, {})
loop1_head=({i -> [0, 8]}, {})
loop1_f=({i -> [0, 8]}, {})
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t=({i -> [0, 8]}, {})
loop1_body=({i -> [0, 8]}, {})
loop1_body_f=({i -> [1, 9]}, {})
loop1_body_x=({i -> [0, 8]}, {})
loop1_body_t=({i -> [1, 9]}, {})
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using Term(Intervals)
entry={}
loop1_head={i -> t0[_z0]}{_z0 -> [0, 8]}
loop1_f={i -> t0[_z0]}{_z0 -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> t0[_z0]}{_z0 -> [0, 8]}
loop1_body={i -> t0[_z0]}{_z0 -> [0, 8]}
loop1_body_f={i -> t2[_z2]}{_z0 -> [0, 8]; _z1 -> [1, 1]; _z2 -> [1, 9]}
loop1_body_x={i -> t0[_x0]}{_x0 -> [0, 8]}
loop1_body_t={i -> t2[_z2]}{_z0 -> [0, 8]; _z1 -> [1, 1]; _z2 -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

Invariants using DisjunctiveIntervals
entry={}
loop1_head={i -> [0, 8]}
loop1_f={i -> [0, 8]}
cont=_|_
loop2_head=_|_
loop2_f=_|_
ret=_|_
loop2_t=_|_
loop2_body=_|_
loop1_t={i -> [0, 8]}
loop1_body={i -> [0, 8]}
loop1_body_f={i -> [1, 9]}
loop1_body_x={i -> [0, 8]}
loop1_body_t={i -> [1, 9]}
Abstract trace: entry (loop1_head loop1_t loop1_body loop1_body_f loop1_body_t loop1_body_x)^{3} loop1_f cont (loop2_head loop2_t loop2_body)^{1} loop2_f ret

entry:
  x = 1;
  y = 0;
  goto header;
header:
  goto body,exit;
body:
  x = x+y;
  y = y+1;
  goto header;
exit:
  assert(-x+y <= 0);


Invariants using Intervals
entry={}
header={x -> [1, +oo]; y -> [0, +oo]}
exit={x -> [1, +oo]; y -> [0, +oo]}
body={x -> [1, +oo]; y -> [0, +oo]}
Abstract trace: entry (header body)^{3} exit

Invariants using Boxes
entry={}
header={}
exit={}
body={}
Abstract trace: entry (header body)^{6} exit

entry:
  i = 0;
  p = 0;
  goto loop_head;
loop_head:
  goto loop_t,loop_f;
loop_t:
  assume(i <= 9);
  i = i+1;
  p = p+4;
  goto loop_head;
loop_f:
  assume(-i <= -10);
  goto ret;
ret:


Invariants using Intervals
entry={}
loop_head={i -> [0, 10]; p -> [0, +oo]}
loop_f={i -> [0, 10]; p -> [0, +oo]}
ret={i -> [10, 10]; p -> [0, +oo]}
loop_t={i -> [0, 10]; p -> [0, +oo]}
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

Invariants using SparseDBM
entry={}
loop_head={i -> [0, 10], p -> [0, +oo], i-p<=0}
loop_f={i -> [0, 10], p -> [0, +oo], i-p<=0}
ret={i -> [10, 10], p -> [10, +oo], i-p<=0}
loop_t={i -> [0, 10], p -> [0, +oo], i-p<=0}
Abstract trace: entry (loop_head loop_t)^{3} loop_f ret

Invariants using SplitDBM
entry={}
loop_head={i -> [0, 10], p -> [0, +oo], i-p<=0}
loop_f={i -> [0, 10], p -> [0, +oo], i-p<=0}
ret={i -> [10, 10], p -> [10, +oo], i-p<=0}
loop_t={i -> [0, 10], p -> [0, +oo], i-p<=0}
Abstract trace: entry (loop_head loop_t)^{3} loop_f ret

Invariants using Product(Intervals,Congruences)
entry=({}, {})
loop_head=({i -> [0, 10]; p -> [0, +oo]}, {p -> 4Z+0})
loop_f=({i -> [0, 10]; p -> [0, +oo]}, {p -> 4Z+0})
ret=({i -> [10, 10]; p -> [0, +oo]}, {i -> 10; p -> 4Z+0})
loop_t=({i -> [0, 10]; p -> [0, +oo]}, {p -> 4Z+0})
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

Invariants using Term(Intervals)
entry={}
loop_head={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [0, +oo]}
loop_f={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [0, +oo]}
ret={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [10, 10]; _y1 -> [0, +oo]}
loop_t={i -> t0[_y0], p -> t1[_y1]}{_y0 -> [0, 10]; _y1 -> [0, +oo]}
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

Invariants using DisjunctiveIntervals
entry={}
loop_head={i -> [0, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
loop_f={i -> [0, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
ret={i -> [10, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
loop_t={i -> [0, 10]; p -> [0, 0] | [4, 4] | [8, 8] | [12, 12] | [16, +oo]}
Abstract trace: entry (loop_head loop_t)^{4} loop_f ret

Running ELINA

INITIALLY={}
ADDING CONSTRAINTS={-x <= -1; x <= 1}
EXPECTED={x = 1}
RESULT={-x <= -1; x <= 1}
------------------------------------
INITIALLY={}
ADDING CONSTRAINTS={-x <= -1/2; x <= 1/2}
EXPECTED={x = 1/2}
RESULT={-x <= -1/2; x <= 1/2}
------------------------------------
INITIALLY={}
ADDING CONSTRAINTS={-x <= -1/2; x <= 1/2}
EXPECTED={x = 1/2}
RESULT={-x <= -1/2; x <= 1/2}
------------------------------------
entry:
  i = 0;
  x = 1;
  y = 0;
  z = 3;
  w = 3;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i <= 99);
  goto bb2;
bb2:
  havoc(nd1);
  havoc(nd2);
  x = x+y;
  y = y+1;
  z = z^nd1;
  w = w^nd1;
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i <= -100);
  goto exit;
exit:
  assume(x-y <= 0);
  goto ret;
ret:



Invariants using SparseDBM
entry={}
bb1={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
bb1_f={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
exit={x -> [100, +oo], y -> [100, 100], y-x<=0}
ret={x -> [100, 100], y -> [100, 100], y-x<=0, x-y<=0}
bb1_t={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
bb2={i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, i-x<=0, y-x<=0, i-y<=0}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f exit ret

Invariants using SplitDBM
entry={}
bb1={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb1_f={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
exit={x -> [100, +oo], y -> [100, 100], y-x<=0}
ret={x -> [100, 100], y -> [100, 100], y-x<=0, x-y<=0}
bb1_t={i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
bb2={i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f exit ret

Invariants using Term(DisjunctiveIntervals)
entry={}
bb1={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}
bb1_f={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}
exit={x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [100, 100]; _y1 -> [1, +oo]}
ret={x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [100, 100]; _y1 -> [1, 100]}
bb1_t={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}
bb2={i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 99]; _y1 -> [1, +oo]}
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f exit ret

Invariants using ReducedProduct(Term(DisjunctiveIntervals),SplitDBM)
entry=({}, {})
bb1=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}, {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
bb1_f=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}, {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
exit=({x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [100, 100]; _y1 -> [100, +oo]}, {x -> [100, +oo], y -> [100, 100], y-x<=0, w-z<=0, z-w<=0})
ret=({x -> t3[_y3], y -> t3[_y3], z -> t0[_y4], w -> t0[_y4]}{_y3 -> [100, 100]}, {x -> [100, 100], y -> [100, 100], y-x<=0, x-y<=0, w-z<=0, z-w<=0})
bb1_t=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 100]; _y1 -> [1, +oo]}, {i -> [0, 100], x -> [1, +oo], y -> [0, 100], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
bb2=({i -> t0[_y0], x -> t1[_y1], y -> t0[_y0], z -> t2[_y2], w -> t2[_y2]}{_y0 -> [0, 99]; _y1 -> [1, +oo]}, {i -> [0, 99], x -> [1, +oo], y -> [0, 99], y-i<=0, y-x<=0, i-x<=0, i-y<=0, w-z<=0, z-w<=0})
Abstract trace: entry (bb1 bb1_t bb2)^{4} bb1_f exit ret

entry:
  i = 0;
  bf = false ;
  bt = true ;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  b1 = (i <= 99);
  assume(b1);
  assert(b1);
  goto bb2;
bb2:
  havoc(nd);
  inc = ite(-nd <= -1,1,2);
  i = i+inc;
  b3 = (-i <= -1);
  b4 = b3;
  b4 = b4|bf;
  b4 = b4&bt;
  b4 = b4^bt;
  b4 = b4^bt;
  goto bb1;
bb1_f:
  b2 = (-i <= -100);
  assume(b2);
  goto ret;
ret:


Invariants using Intervals
entry={}
bb1={i -> [0, +oo]}
bb1_f={i -> [0, +oo]}
ret={i -> [0, +oo]}
bb1_t={i -> [0, +oo]}
bb2={i -> [0, +oo]}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using Product(Boolean,SparseDBM)
entry=({}, {})
bb1=({bf -> false; bt -> true}, {i -> [0, 101]})
bb1_f=({bf -> false; bt -> true}, {i -> [0, 101]})
ret=({b2 -> true; bf -> false; bt -> true}, {i -> [100, 101]})
bb1_t=({bf -> false; bt -> true}, {i -> [0, 101]})
bb2=({b1 -> true; bf -> false; bt -> true}, {i -> [0, 99]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using Boxes
entry={}
bb1={-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; -nd <= -1; -inc <= -1; inc <= 1; -b3 <= -1; -b4 <= -1} or 
{-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; nd <= 0; -inc <= -2; inc <= 2; -b3 <= -1; -b4 <= -1} or 
{-i <= 0; i <= 0; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1}
bb1_f={-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; -nd <= -1; -inc <= -1; inc <= 1; -b3 <= -1; -b4 <= -1} or 
{-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; nd <= 0; -inc <= -2; inc <= 2; -b3 <= -1; -b4 <= -1} or 
{-i <= 0; i <= 0; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1}
ret={-i <= -100; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; -nd <= -1; -inc <= -1; inc <= 1; -b3 <= -1; -b4 <= -1; -b2 <= -1} or 
{-i <= -100; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; nd <= 0; -inc <= -2; inc <= 2; -b3 <= -1; -b4 <= -1; -b2 <= -1}
bb1_t={-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; -nd <= -1; -inc <= -1; inc <= 1; -b3 <= -1; -b4 <= -1} or 
{-i <= -1; i <= 101; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; nd <= 0; -inc <= -2; inc <= 2; -b3 <= -1; -b4 <= -1} or 
{-i <= 0; i <= 0; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1}
bb2={-i <= -1; i <= 99; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; -nd <= -1; -inc <= -1; inc <= 1; -b3 <= -1; -b4 <= -1} or 
{-i <= -1; i <= 99; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1; nd <= 0; -inc <= -2; inc <= 2; -b3 <= -1; -b4 <= -1} or 
{-i <= 0; i <= 0; -bf <= 0; bf <= 0; -bt <= -1; bt <= 1; -b1 <= -1}
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

entry:
  i = 0;
  havoc(n);
  b = (n = 10);
  assume(b);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i-n <= 0);
  goto bb2;
bb2:
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i+n <= -1);
  goto ret;
ret:
  assert(i = 10);


Invariants using Product(Boolean,Intervals)
entry=({}, {})
bb1=({b -> true}, {i -> [0, 11]; n -> [10, 10]})
bb1_f=({b -> true}, {i -> [0, 11]; n -> [10, 10]})
ret=({b -> true}, {i -> [11, 11]; n -> [10, 10]})
bb1_t=({b -> true}, {i -> [0, 11]; n -> [10, 10]})
bb2=({b -> true}, {i -> [0, 10]; n -> [10, 10]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

entry:
  i = 0;
  havoc(n);
  b = (n = 10);
  goto bb0,entry_cnt;
bb0:
  n = 1;
  goto entry_cnt;
entry_cnt:
  assume(b);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i-n <= 0);
  goto bb2;
bb2:
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i+n <= -1);
  goto ret;
ret:
  assert(i = 10);


Invariants using Product(Boolean,Intervals)
entry=({}, {})
entry_cnt=({}, {i -> [0, 0]})
bb1=({b -> true}, {i -> [0, +oo]})
bb1_f=({b -> true}, {i -> [0, +oo]})
ret=({b -> true}, {i -> [0, +oo]})
bb1_t=({b -> true}, {i -> [0, +oo]})
bb2=({b -> true}, {i -> [0, +oo]; n -> [0, +oo]})
bb0=({}, {i -> [0, 0]})
Abstract trace: entry bb0 entry_cnt (bb1 bb1_t bb2)^{3} bb1_f ret

entry:
  i = 0;
  havoc(n);
  trunc n:64 to n1:32;
  b1 = (n1 = 9);
  assume(b1);
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(i-n <= 0);
  goto bb2;
bb2:
  i = i+1;
  goto bb1;
bb1_f:
  assume(-i+n <= -1);
  goto ret;
ret:
  assert(i = 10);


Invariants using Product(Boolean,Intervals)
entry=({}, {})
bb1=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
bb1_f=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
ret=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
bb1_t=({b1 -> true}, {i -> [0, +oo]; n1 -> [9, 9]})
bb2=({b1 -> true}, {i -> [0, +oo]; n -> [0, +oo]; n1 -> [9, 9]})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using Product(Boolean,SparseDBM)
entry=({}, {})
bb1=({b1 -> true}, {i -> [0, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
bb1_f=({b1 -> true}, {i -> [0, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
ret=({b1 -> true}, {i -> [10, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=-1, n-i<=-1, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
bb1_t=({b1 -> true}, {i -> [0, 10], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=1, n-n1<=0, i-n1<=1})
bb2=({b1 -> true}, {i -> [0, 9], n -> [9, 9], n1 -> [9, 9], n1-i<=9, n-i<=9, n1-n<=0, i-n<=0, n-n1<=0, i-n1<=0})
Abstract trace: entry (bb1 bb1_t bb2)^{3} bb1_f ret

loop1_entry:
  i = 0;
  k = 30;
  goto loop1_bb1;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(i <= 9);
  goto loop1_bb2;
loop1_bb2:
  i = i+1;
  goto loop1_bb1;
loop1_bb1_f:
  assume(-i <= -10);
  goto loop2_entry;
loop2_entry:
  j = 0;
  goto loop2_bb1;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(j <= 9);
  goto loop2_bb2;
loop2_bb2:
  j = j+1;
  goto loop2_bb1;
loop2_bb1_f:
  assume(-j <= -10);
  goto ret;
ret:


Starting at the entry of CFG:
Invariants using Intervals
loop1_entry={}
loop1_bb1={i -> [0, 10]; k -> [30, 30]}
loop1_bb1_f={i -> [0, 10]; k -> [30, 30]}
loop2_entry={i -> [10, 10]; k -> [30, 30]}
loop2_bb1={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb1_f={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
ret={i -> [10, 10]; j -> [10, 10]; k -> [30, 30]}
loop2_bb1_t={i -> [10, 10]; j -> [0, 10]; k -> [30, 30]}
loop2_bb2={i -> [10, 10]; j -> [0, 9]; k -> [30, 30]}
loop1_bb1_t={i -> [0, 10]; k -> [30, 30]}
loop1_bb2={i -> [0, 9]; k -> [30, 30]}
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2)^{3} loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

Starting at the entry of the second loop:
Invariants using Intervals
loop1_entry=_|_
loop1_bb1=_|_
loop1_bb1_f=_|_
loop2_entry={}
loop2_bb1={j -> [0, 10]}
loop2_bb1_f={j -> [0, 10]}
ret={j -> [10, 10]}
loop2_bb1_t={j -> [0, 10]}
loop2_bb2={j -> [0, 9]}
loop1_bb1_t=_|_
loop1_bb2=_|_
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2) loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{3} loop2_bb1_f ret

Starting at the middle of the second loop:
Invariants using Intervals
loop1_entry=_|_
loop1_bb1=_|_
loop1_bb1_f=_|_
loop2_entry=_|_
loop2_bb1={}
loop2_bb1_f={}
ret={j -> [10, +oo]}
loop2_bb1_t={}
loop2_bb2={}
loop1_bb1_t=_|_
loop1_bb2=_|_
Abstract trace: loop1_entry (loop1_bb1 loop1_bb1_t loop1_bb2) loop1_bb1_f loop2_entry (loop2_bb1 loop2_bb1_t loop2_bb2)^{1} loop2_bb1_f ret

Thresholds= {-oo,-999,-89,-10,0,5,10,100,1000,+oo}
next threshold for 3:5
next threshold for 8: 10
next threshold for 100: 1000
next threshold for 500: 1000
next threshold for 10000: +oo
next threshold for -4: 0
prev threshold for -4:-10
prev threshold for -78:-89
prev threshold for -10000:-oo
entry:
  n = 0;
  goto l_1;
l_1:
  goto l_2;
l_2:
  goto l_1,l_3;
l_3:
  goto l_4,l_5;
l_4:
  assume(n <= 59);
  n = n+1;
  goto l_6;
l_6:
  goto l_1;
l_5:
  assume(-n <= -60);
  n = 0;
  goto l_6;

Invariants using Intervals
entry={}
l_1={n -> [0, +oo]}
l_2={n -> [0, +oo]}
l_3={n -> [0, +oo]}
l_5={n -> [0, +oo]}
l_6={n -> [0, 60]}
l_4={n -> [0, +oo]}
Abstract trace: entry (l_1 l_2 l_3 l_5 l_4 l_6)^{3}

Invariants using Intervals
entry={}
l_1={n -> [0, 60]}
l_2={n -> [0, 60]}
l_3={n -> [0, 60]}
l_5={n -> [0, 60]}
l_6={n -> [0, 60]}
l_4={n -> [0, 60]}
Abstract trace: entry (l_1 l_2 l_3 l_5 l_4 l_6)^{3}

entry:
  n = 0;
  goto loop1_header;
loop1_header:
  goto loop1_bb0,loop1_bb1,cont;
loop1_bb0:
  havoc(x);
  assume(-x <= 0);
  goto loop1_header;
loop1_bb1:
  goto loop1_bb1_t,loop1_bb1_f;
loop1_bb1_t:
  assume(n <= 59);
  goto loop1_bb2;
loop1_bb2:
  n = n+1;
  goto loop1_bb4;
loop1_bb4:
  goto loop1_header;
loop1_bb1_f:
  assume(-n <= -60);
  goto loop1_bb3;
loop1_bb3:
  n = 0;
  goto loop1_bb4;
cont:
  n = 0;
  goto loop2_header;
loop2_header:
  goto loop2_bb0,loop2_bb1,ret;
loop2_bb0:
  havoc(x);
  assume(-x <= -10);
  goto loop2_header;
loop2_bb1:
  goto loop2_bb1_t,loop2_bb1_f;
loop2_bb1_t:
  assume(n <= 160);
  goto loop2_bb2;
loop2_bb2:
  n = n+2;
  goto loop2_bb4;
loop2_bb4:
  goto loop2_header;
loop2_bb1_f:
  assume(-n <= -161);
  goto loop2_bb3;
loop2_bb3:
  n = 0;
  goto loop2_bb4;
ret:


Thresholds per loop 
loop2_header={-oo,0,9,161,+oo}
loop1_header={-oo,-1,60,+oo}

Unit tests for array adaptive domain

({}, {A[4...7] -> [5, 5]; B[0...3] -> [66, 66]}) | ({}, {A[4...7] -> [10, 10]; C[8...11] -> [32, 32]})=({}, {A[4...7] -> [5, 10]})
({}, {A[4...7] -> [5, 5]; B[0...3] -> [66, 66]}) |= ({}, {A[4...7] -> [10, 10]; C[8...11] -> [32, 32]})=({}, {A[4...7] -> [5, 10]})
({}, {A[4...7] -> [5, 5]; B[0...3] -> [66, 66]}) & ({}, {A[4...7] -> [10, 10]; C[8...11] -> [32, 32]})=_|_
({}, {A[4...7] -> [5, 5]; B[0...3] -> [66, 66]}) & ({}, {A[4...7] -> [5, 5]; C[8...11] -> [32, 32]})=({}, {B[0...3] -> [66, 66]; C[8...11] -> [32, 32]; A[4...7] -> [5, 5]})
============================
Test using ArrayExpansion(Intervals)
EXPECTED: {M[4..7] >= 1} 
RESULT: {M[4...7] -> [1, +oo]}
============================
Test using ArrayExpansion(Intervals)
EXPECTED: {z >= 2, ...}
RESULT: {x -> [2, +oo]; y -> [1, +oo]; z -> [2, +oo]}
============================
Test using ArrayExpansion(Intervals)
EXPECTED: _|_
RESULT: _|_
============================
Test using ArrayExpansion(Intervals)
EXPECTED: {y >= 2, ...}
RESULT: {x -> [2, +oo]; y -> [2, +oo]}
Before normalize constraints {x <= 8; -y <= -5; y <= 6; -x <= -8; -v <= -9888; z = 10; w <= 0; v <= 9888}
After normalize constraints {x = 8; v = 9888; -y <= -5; y <= 6; z = 10; w <= 0}
 ===== Intervals ====
Before renaming {x -> [-oo, 0]; y -> [5, 5]}
After rename x with w and y with z={z -> [5, 5]; w -> [-oo, 0]}
After rename x with w={y -> [5, 5]; w -> [-oo, 0]}
 ===== ElinaPolyhedra ====
Before renaming {-y = -5; x <= 0}
After rename x with w and y with z={w <= 0; -z = -5}
After rename x with w={w <= 0; -y = -5}
 ===== SplitDBM ====
Before renaming {x -> [-oo, 0], y -> [5, 5]}
After rename x with w and y with z={w -> [-oo, 0], z -> [5, 5]}
After rename x with w={w -> [-oo, 0], y -> [5, 5]}
 ===== SparseDBM ====
Before renaming {x -> [-oo, 0], y -> [5, 5], x-y<=-5}
After rename x with w and y with z={w -> [-oo, 0], z -> [5, 5], w-z<=-5}
After rename x with w={w -> [-oo, 0], y -> [5, 5], w-y<=-5}
 ===== Term(Intervals) ====
Before renaming {x -> t0[_x0], y -> t1[_x1]}{_x0 -> [-oo, 0]; _x1 -> [5, 5]}
After rename x with w and y with z={z -> t1[_x1], w -> t0[_x0]}{_x0 -> [-oo, 0]; _x1 -> [5, 5]}
After rename x with w={y -> t1[_x1], w -> t0[_x0]}{_x0 -> [-oo, 0]; _x1 -> [5, 5]}
{A -> [0, +oo], x -> [0, 0], x-A<=0}
Before x != 0: {x -> [0, 10], y -> [0, 10], z -> [0, 10], y-x<=0, z-x<=0, x-y<=0, z-y<=0, x-z<=0, y-z<=0}
After x != 0: {x -> [1, 10], y -> [1, 10], z -> [1, 10], y-x<=0, z-x<=0, x-y<=0, z-y<=0, x-z<=0, y-z<=0}
Before x != 10: {x -> [0, 10], y -> [0, 10], z -> [0, 10], y-x<=0, z-x<=0, x-y<=0, z-y<=0, u-v<=0, v-u<=0, x-z<=0, y-z<=0}
After x != 10: {x -> [0, 9], y -> [0, 9], z -> [0, 9], y-x<=0, z-x<=0, x-y<=0, z-y<=0, u-v<=0, v-u<=0, x-z<=0, y-z<=0}
DBM1={x -> [1, 1], y -> [1, 1], y-x<=0, x-y<=0}
DBM2={y -> [1, +oo]}
DBM1 & DBM2={y -> [1, 1], x -> [1, 1], x-y<=0, y-x<=0}
Before normalize constraints {x <= 8; -y <= -5; y <= 6; -x <= -8; -v <= -9888; z = 10; w <= 0; v <= 9888}
After normalize constraints {x = 8; v = 9888; -y <= -5; y <= 6; z = 10; w <= 0}
Adding constraint 1 x = -9223372036854775808
Dom1={}
Csts1={}
Adding constraint 2 x = -9223372036854775807
Dom2={x -> [-9223372036854775807, -9223372036854775807]}
Csts2={-x <= 9223372036854775807; x <= -9223372036854775807}
{y -> [0, +oo], x -> [0, 9223372036854775296]}
Bitwidth=3
5+7=4
5-7=6
5*7=3
1450 converted to 2
Bitwidth=8
5+7=12
5-7=254
5*7=35
224/2=240
5%7=5
Bitwidth=64
5+7=12
5-7=18446744073709551614
5*7=35
n1=0111
n2=1100
sext of n1 to 8 bits 00000111
sext of n2 to 8 bits 11111100
zext of n1 to 8 bits 00000111
zext of n2 to 8 bits 00001100
n=10101100
zext of n to 16 bits 0000000010101100
sext of n to 16 bits 1111111110101100
n1=00000000000000000000000000000111
n2=11111111111100001011110111000001
sext of n1 to 63 bits 000000000000000000000000000000000000000000000000000000000000111
sext of n2 to 63 bits 111111111111111111111111111111111111111111100001011110111000001
zext of n1 to 63 bits 000000000000000000000000000000000000000000000000000000000000111
zext of n2 to 63 bits 000000000000000000000000000000011111111111100001011110111000001
n1=00000000000000000000000000000111
n2=11111111111100001011110111000001
sext of n1 to 64 bits 0000000000000000000000000000000000000000000000000000000000000111
sext of n2 to 64 bits 1111111111111111111111111111111111111111111100001011110111000001
zext of n1 to 64 bits 0000000000000000000000000000000000000000000000000000000000000111
zext of n2 to 64 bits 0000000000000000000000000000000011111111111100001011110111000001
1101 << 0010=0100
1101 >>_a 0010=1111
1101 >>_l 0010=0011
1001 /_s 0010 =1101
1001 /_u 0010 =0100
0111 %_s 0011 =0001 (1) 
0111 %_s 1101 =0001 (1) 
1001 %_s 0011 =1111 (-1) 
1001 %_s 1101 =1111 (-1) 
0111 %_u 0011 =0001
0111 %_u 1101 =0111
1001 %_s 0011 =0000
1001 %_s 1101 =1001
UMAX(64)=18446744073709551615
1111111111111111111111111111111111111111111111111111111111111111
UMIN(64)=0
0000000000000000000000000000000000000000000000000000000000000000
SMAX(64)=9223372036854775807
0111111111111111111111111111111111111111111111111111111111111111
SMIN(64)=9223372036854775808
1000000000000000000000000000000000000000000000000000000000000000
UMAX(32)=4294967295
11111111111111111111111111111111
UMIN(32)=0
00000000000000000000000000000000
SMAX(32)=2147483647
01111111111111111111111111111111
SMIN(32)=2147483648
10000000000000000000000000000000
UMAX(40)=1099511627775
1111111111111111111111111111111111111111
UMIN(40)=0
0000000000000000000000000000000000000000
SMAX(40)=549755813887
0111111111111111111111111111111111111111
SMIN(40)=549755813888
1000000000000000000000000000000000000000
UMAX(63)=9223372036854775807
111111111111111111111111111111111111111111111111111111111111111
UMIN(63)=0
000000000000000000000000000000000000000000000000000000000000000
SMAX(63)=4611686018427387903
011111111111111111111111111111111111111111111111111111111111111
SMIN(63)=4611686018427387904
100000000000000000000000000000000000000000000000000000000000000
entry:
  y = -10;
  havoc(nd);
  goto bb_nd;
bb_nd:
  goto bb_nd_tt,bb_nd_ff;
bb_nd_tt:
  assume(-nd <= -1);
  x = 0;
  goto bb1;
bb1:
  goto bb1_t,bb1_f;
bb1_t:
  assume(-x+y <= 0);
  goto bb2;
bb2:
  x = x-y;
  goto bb1;
bb1_f:
  assume(x-y <= -1);
  goto ret;
ret:

bb_nd_ff:
  assume(nd <= 0);
  x = 100;
  goto bb1;

Invariants using Intervals
entry={}
bb_nd={y -> [-10, -10]}
bb_nd_ff={y -> [-10, -10]}
bb1={x -> [0, +oo]; y -> [-10, -10]}
bb1_f={x -> [0, +oo]; y -> [-10, -10]}
ret=_|_
bb1_t={x -> [0, +oo]; y -> [-10, -10]}
bb2={x -> [0, +oo]; y -> [-10, -10]}
bb_nd_tt={y -> [-10, -10]}
Abstract trace: entry bb_nd bb_nd_ff bb_nd_tt (bb1 bb1_t bb2)^{3} bb1_f ret

Invariants using WrappedIntervals
entry={}
bb_nd={y -> [[-10, -10]]_8}
bb_nd_ff={y -> [[-10, -10]]_8}
bb1={x -> [[0, -119]]_8; y -> [[-10, -10]]_8}
bb1_f={x -> [[0, -119]]_8; y -> [[-10, -10]]_8}
ret={x -> [[-128, -119]]_8; y -> [[-10, -10]]_8}
bb1_t={x -> [[0, -119]]_8; y -> [[-10, -10]]_8}
bb2={x -> [[0, 127]]_8; y -> [[-10, -10]]_8}
bb_nd_tt={y -> [[-10, -10]]_8}
Abstract trace: entry bb_nd bb_nd_ff bb_nd_tt (bb1 bb1_t bb2)^{3} bb1_f ret

entry:
  x = 127;
  x = x+1;
  goto if,then;
if:
  assume(x <= 1);
  x = 10;
  goto ret;
ret:

then:
  assume(-x <= -2);
  x = -10;
  goto ret;

Invariants using WrappedIntervals
entry={}
then={x -> [[-128, -128]]_8}
ret={x -> [[10, 10]]_8}
if={x -> [[-128, -128]]_8}
Abstract trace: entry then if ret

entry:
  x = 127;
  x = x+1;
  goto if,then;
if:
  assume(x <=_u 1);
  x = 10;
  goto ret;
ret:

then:
  assume(-x <=_u -2);
  x = -10;
  goto ret;

Invariants using WrappedIntervals
entry={}
then={x -> [[-128, -128]]_8}
ret={x -> [[-10, -10]]_8}
if={x -> [[-128, -128]]_8}
Abstract trace: entry then if ret

i1=[[-10, 10]]_8
i2=[[0, 20]]_8
-i2=[[-20, 0]]_8
i1 & i2: [[0, 10]]_8
i1 | i2: [[-10, 20]]_8
[[0, -10]]_8 & [[-15, 5]]_8: [[-15, 5]]_8
[[0, -10]]_8 | [[-15, 5]]_8: top
urk: [[1642571628, 700177772]]_32
urk.is_top(): 0
urk == Top: 0
[[-1, -7]]_4 * [[0, 1]]_4 = [[-1, -7]]_4
[[4, 7]]_4 /_s [[-2, 3]]_4 = [[1, -2]]_4
[[4, 7]]_4 /_u [[-2, 3]]_4 = [[0, 7]]_4
[[4, 7]]_4 /_s [[2, 2]]_4 = [[2, 3]]_4
[[4, 7]]_4 /_u [[2, 2]]_4 = [[2, 3]]_4
